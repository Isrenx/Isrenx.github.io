<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Isrenx</title>
  <subtitle>在这里记录学习轨迹、记录生活。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-02T12:07:00.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Victor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6学习笔记-第三篇(变量的结构赋值)</title>
    <link href="http://yoursite.com/2017/06/02/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2017/06/02/ES6学习笔记-第三篇-变量的结构赋值/</id>
    <published>2017-06-02T07:07:19.000Z</published>
    <updated>2017-06-02T12:07:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h1><p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//ES6之前</div><div class="line">let a = 1;</div><div class="line">let b = 2;</div><div class="line">let c = 3;</div><div class="line">//ES6</div><div class="line">let [a,b,c] = [1,2,3];</div></pre></td></tr></table></figure></p>
<p>上面代码表示：可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>下面是一些使用嵌套数组进行解构的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">let [foo,[[bar],baz]] = [1,[[2],3]];</div><div class="line">foo;//1</div><div class="line">bar;//2</div><div class="line">baz;//3</div><div class="line"></div><div class="line">let [,,third] = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;];</div><div class="line">third; //&quot;baz&quot;</div><div class="line"></div><div class="line">let [x,,y] = [1,2,3];</div><div class="line">x; //1</div><div class="line">y; //3</div><div class="line"></div><div class="line">let [head,...tail] = [1,2,3,4];</div><div class="line">head;//1</div><div class="line">tail;//[2,3,4]</div><div class="line"></div><div class="line">let [x,y,...z] = [&apos;a&apos;];</div><div class="line">x; //&quot;a&quot;</div><div class="line">y; //undefined</div><div class="line">z; //[]</div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就为<code>undefined</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let [foo] = [];</div><div class="line">let [bar,foo] = [1];</div><div class="line">console.log(bar+&apos;,&apos;+foo);//1,undefined</div></pre></td></tr></table></figure></p>
<p>注：以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code><br>△:在等式的两边，若左边中某个值在右边对应的值是控制，则解构失败，输出undefined;若右边的值对应的左边的值不存在或为空，不报错。  </p>
<h2 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h2><p>1.可以不完全解构；即等号左边的模式，只匹配一部分的等号右边的数组；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">let [x, y] = [1, 2, 3];</div><div class="line">x // 1</div><div class="line">y // 2</div><div class="line"></div><div class="line">let [a, [b], d] = [1, [2, 3], 4];</div><div class="line">a // 1</div><div class="line">b // 2</div><div class="line">d // 4</div></pre></td></tr></table></figure></p>
<p>2.若等号右边的不是数组（严格地说，不是可遍历的结构），那么将会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">let [foo] = 1;</div><div class="line">let [foo] = false;</div><div class="line">let [foo] = NaN;</div><div class="line">let [foo] = undefined;</div><div class="line">let [foo] = null;</div><div class="line">let [foo] = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>3.<code>set</code>结构，也可以使用数组的解构赋值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let [x, y, z] = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);</div><div class="line">x // &quot;a&quot;</div></pre></td></tr></table></figure></p>
<p>4.只要数据具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function* fibs() &#123;</div><div class="line">  let a = 0;</div><div class="line">  let b = 1;</div><div class="line">  while (true) &#123;</div><div class="line">    yield a;</div><div class="line">    [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth // 5</div></pre></td></tr></table></figure></p>
<p><code>Iterator</code>接口:其实就是指那些能够被遍历的数据。ES6 有一种新的遍历形式<code>for..of</code>，而<code>Iterator</code>的主要作用，就是支持此操作。<br>ESs6中有三类结构生来就具有<code>Iterator</code>接口：数组、类数组对象、Map和Set结构。  </p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>解构赋值允许指定默认值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let [foo = true] = [];</div><div class="line">foo;//true</div><div class="line"></div><div class="line">let [x,y = &quot;b&quot;] = [&quot;a&quot;];//x=&quot;a&quot;,y=&quot;b&quot;</div><div class="line">let [x,y = &quot;b&quot;] = [&quot;a&quot;,undefined];//x=&quot;a&quot;,y=&quot;b&quot;</div></pre></td></tr></table></figure></p>
<p>注：ES6内部使用严格相等运算符<code>===</code>判断一个位置是否有值。因此，如果一个数组成员不严格等于<code>undefined</code>,默认值是不会生效的。<br>以上代码中，第一个<code>y</code>因为对应右边的值为空是<code>undefined</code>,所以设置的默认值生效；第二个<code>y</code>也是如此，因为右边对应的值就是<code>undefined</code>,因此<code>y</code>就为<code>b</code>;  </p>
<h2 id="默认值的用法"><a href="#默认值的用法" class="headerlink" title="默认值的用法"></a>默认值的用法</h2><p>1.如果默认值是一个表达式，那么这个表达式是惰性求值的。即只有在用到的时候，才会求值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function f()&#123;</div><div class="line">    console.log(&quot;aaa&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    let [x = f()] = [1];</div><div class="line">    console.log(x);//1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在以上代码中，因为x能够取到值，所以函数<code>f</code>根本不会执行。  </p>
<p>2.默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let [x = 1, y = x] = [];     // x=1; y=1</div><div class="line">let [x = 1, y = x] = [2];    // x=2; y=2</div><div class="line">let [x = 1, y = x] = [1, 2]; // x=1; y=2</div><div class="line">let [x = y, y = 1] = [];     // ReferenceError</div></pre></td></tr></table></figure></p>
<h1 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h1><p>解构不仅可以用于数组，还能用于对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let &#123; foo, bar,baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</div><div class="line">foo // &quot;aaa&quot;</div><div class="line">bar // &quot;bbb&quot;</div><div class="line">baz // undefined</div></pre></td></tr></table></figure></p>
<p>1.对象与数组解构不同点：数组的元素是按次序排列的，变量的取值由它的位置决定。而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。  </p>
<p>2.如果变量名和属性名字不一致，必须按照下面这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;</div><div class="line">baz // &quot;aaa&quot;</div><div class="line"></div><div class="line">let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;</div><div class="line">let &#123; first: f, last: l &#125; = obj;</div><div class="line">f // &apos;hello&apos;</div><div class="line">l // &apos;world&apos;</div></pre></td></tr></table></figure></p>
<p>注：<code>foo</code>是匹配模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>;  </p>
<p>3.<code>let</code>和<code>const</code>声明的变量，变量不能重新声明。在解构变量时也要遵守这个规则。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let foo;</div><div class="line">(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功</div><div class="line"></div><div class="line">let baz;</div><div class="line">(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>let</code>命令下面一行的圆括号是必须的。因为，解析器先解析起首的大括号，理解成一个代码块而不是赋值语句。  </p>
<p>4.解构可用于嵌套解构的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;</div><div class="line">  p: [</div><div class="line">    &apos;Hello&apos;,</div><div class="line">    &#123; y: &apos;World&apos; &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; p: [x, &#123; y &#125;] &#125; = obj;</div><div class="line">x // &quot;Hello&quot;</div><div class="line">y // &quot;World&quot;</div></pre></td></tr></table></figure></p>
<p>注：这是的<code>p</code>是模式，不是变量，因此不会被赋值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var node = &#123;</div><div class="line">  loc: &#123;</div><div class="line">    start: &#123;</div><div class="line">      line: 1,</div><div class="line">      column: 5</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;</div><div class="line">line // 1</div><div class="line">loc  // error: loc is undefined</div><div class="line">start // error: start is undefined</div></pre></td></tr></table></figure></p>
<p>注：上面代码中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p>
<p>嵌套eg:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let obj = &#123;&#125;;</div><div class="line">let arr = [];</div><div class="line"></div><div class="line">(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);</div><div class="line"></div><div class="line">obj // &#123;prop:123&#125;</div><div class="line">arr // [true]</div></pre></td></tr></table></figure></p>
<p>5.对象也可以指定默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var &#123;x = 3&#125; = &#123;&#125;;</div><div class="line">x // 3</div><div class="line"></div><div class="line">var &#123;x, y = 5&#125; = &#123;x: 1&#125;;</div><div class="line">x // 1</div><div class="line">y // 5</div><div class="line"></div><div class="line">var &#123;x:y = 3&#125; = &#123;&#125;;</div><div class="line">y // 3</div><div class="line"></div><div class="line">var &#123;x:y = 3&#125; = &#123;x: 5&#125;;</div><div class="line">y // 5</div><div class="line"></div><div class="line">var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;</div><div class="line">msg // &quot;Something went wrong&quot;</div></pre></td></tr></table></figure></p>
<p>6.默认值生效的条件是，对象属性值严格等于<code>undefined</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var &#123;x = 3&#125; = &#123;x: undefined&#125;;</div><div class="line">x // 3</div><div class="line"></div><div class="line">var &#123;x = 3&#125; = &#123;x: null&#125;;</div><div class="line">x // null</div></pre></td></tr></table></figure></p>
<p>7.解构失败，变量的值等于<code>undefined</code><br>8.解构模式是嵌套的对象，而且子对象所在的浮属性不存在，就会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;;</div></pre></td></tr></table></figure></p>
<p>9.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let arr = [1, 2, 3];</div><div class="line">let &#123;0 : first, [arr.length - 1] : last&#125; = arr;</div><div class="line">first // 1</div><div class="line">last // 3</div></pre></td></tr></table></figure></p>
<h1 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h1><p>字符串也可以解构赋值。因为，字符串被转换成了一个类似数组的对象；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">const [a, b, c, d, e] = &apos;hello&apos;;</div><div class="line">a // &quot;h&quot;</div><div class="line">b // &quot;e&quot;</div><div class="line">c // &quot;l&quot;</div><div class="line">d // &quot;l&quot;</div><div class="line">e // &quot;o&quot;</div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123;length : len&#125; = &apos;hello&apos;;</div><div class="line">len // 5</div></pre></td></tr></table></figure></p>
<h1 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h1><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">let &#123;toString: s&#125; = 123;</div><div class="line">s === Number.prototype.toString // true</div><div class="line"></div><div class="line">let &#123;toString: s&#125; = true;</div><div class="line">s === Boolean.prototype.toString // true</div></pre></td></tr></table></figure></p>
<p>上面代码中，数值和布尔值的包装对象都有<code>toSting</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是：只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let &#123; prop: x &#125; = undefined; // TypeError</div><div class="line">let &#123; prop: y &#125; = null; // TypeError</div></pre></td></tr></table></figure></p>
<h1 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h1><p>函数的参数也可以使用解构赋值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add([x, y])&#123;</div><div class="line">  return x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([1, 2]); // 3</div></pre></td></tr></table></figure></p>
<p>上面代码中：函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数是<code>x</code>和<code>y</code>.  </p>
<p>1.函数参数的结构也可以使用默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</div><div class="line">  return [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;x: 3, y: 8&#125;); // [3, 8]</div><div class="line">move(&#123;x: 3&#125;); // [3, 0]</div><div class="line">move(&#123;&#125;); // [0, 0]</div><div class="line">move(); // [0, 0]</div></pre></td></tr></table></figure></p>
<p>2.<code>undefined</code>触发函数参数的默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);</div><div class="line">// [ 1, &apos;yes&apos;, 3 ]</div></pre></td></tr></table></figure></p>
<h1 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h1><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。  </p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。  </p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<hr>
<h2 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h2><p>1.变量声明语句，不能带圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 全部报错</div><div class="line">let [(a)] = [1];</div><div class="line"></div><div class="line">let &#123;x: (c)&#125; = &#123;&#125;;</div><div class="line">let (&#123;x: c&#125;) = &#123;&#125;;</div><div class="line">let &#123;(x: c)&#125; = &#123;&#125;;</div><div class="line">let &#123;(x): c&#125; = &#123;&#125;;</div><div class="line"></div><div class="line">let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;;</div></pre></td></tr></table></figure></p>
<p>注：模式不能使用圆括号；  </p>
<p>2.函数参数中（函数参数也属于变量声明），模式不能带有圆括号。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 报错</div><div class="line">function f([(z)]) &#123; return z; &#125;</div></pre></td></tr></table></figure></p>
<p>3.赋值语句中，不能将整个模式或嵌套模式中的一层，放在圆括号中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 全部报错</div><div class="line">(&#123; p: a &#125;) = &#123; p: 42 &#125;;</div><div class="line">([a]) = [5];</div></pre></td></tr></table></figure></p>
<h2 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h2><p>1.赋值语句的非模式部分可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[(b)] = [3]; // 正确</div><div class="line">(&#123; p: (d) &#125; = &#123;&#125;); // 正确</div><div class="line">[(parseInt.prop)] = [3]; // 正确</div></pre></td></tr></table></figure></p>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><h2 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x = 1;</div><div class="line">let y = 2;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<h2 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 返回一个数组</div><div class="line"></div><div class="line">function example() &#123;</div><div class="line">  return [1, 2, 3];</div><div class="line">&#125;</div><div class="line">let [a, b, c] = example();</div><div class="line"></div><div class="line">// 返回一个对象</div><div class="line"></div><div class="line">function example() &#123;</div><div class="line">  return &#123;</div><div class="line">    foo: 1,</div><div class="line">    bar: 2</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">let &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>
<h2 id="函数参数定义"><a href="#函数参数定义" class="headerlink" title="函数参数定义"></a>函数参数定义</h2><p>解构赋值可以方便地将一组参数与变量名对应起来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 参数是一组有次序的值</div><div class="line">function f([x, y, z]) &#123; ... &#125;</div><div class="line">f([1, 2, 3]);</div><div class="line"></div><div class="line">// 参数是一组无次序的值</div><div class="line">function f(&#123;x, y, z&#125;) &#123; ... &#125;</div><div class="line">f(&#123;z: 3, y: 2, x: 1&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let jsonData = &#123;</div><div class="line">  id: 42,</div><div class="line">  status: &quot;OK&quot;,</div><div class="line">  data: [867, 5309]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">let &#123; id, status, data: number &#125; = jsonData;</div><div class="line"></div><div class="line">console.log(id, status, number);</div><div class="line">// 42, &quot;OK&quot;, [867, 5309]</div></pre></td></tr></table></figure>
<h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = function (url, &#123;</div><div class="line">  async = true,</div><div class="line">  beforeSend = function () &#123;&#125;,</div><div class="line">  cache = true,</div><div class="line">  complete = function () &#123;&#125;,</div><div class="line">  crossDomain = false,</div><div class="line">  global = true,</div><div class="line">  // ... more config</div><div class="line">&#125;) &#123;</div><div class="line">  // ... do stuff</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。  </p>
<h2 id="遍历map结构"><a href="#遍历map结构" class="headerlink" title="遍历map结构"></a>遍历map结构</h2><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var map = new Map();</div><div class="line">map.set(&apos;first&apos;, &apos;hello&apos;);</div><div class="line">map.set(&apos;second&apos;, &apos;world&apos;);</div><div class="line"></div><div class="line">for (let [key, value] of map) &#123;</div><div class="line">  console.log(key + &quot; is &quot; + value);</div><div class="line">&#125;</div><div class="line">// first is hello</div><div class="line">// second is world</div></pre></td></tr></table></figure></p>
<p>如果只想获取键名或者只想获取键值，可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 获取键名</div><div class="line">for (let [key] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 获取键值</div><div class="line">for (let [,value] of map) &#123;</div><div class="line">  // ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h2><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组的结构赋值&quot;&gt;&lt;a href=&quot;#数组的结构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的结构赋值&quot;&gt;&lt;/a&gt;数组的结构赋值&lt;/h1&gt;&lt;p&gt;解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。&lt;br&gt;&lt;figu
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="变量的解构赋值" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-第二篇(const)</title>
    <link href="http://yoursite.com/2017/06/02/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AF%87-const/"/>
    <id>http://yoursite.com/2017/06/02/ES6学习笔记-第二篇-const/</id>
    <published>2017-06-02T06:22:27.000Z</published>
    <updated>2017-06-02T07:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h1><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const a = 1;</div><div class="line">console.log(a);//1</div><div class="line"></div><div class="line">a = 2;//报错</div></pre></td></tr></table></figure></p>
<p><code>const</code>声明的变量不得改变值，这表明，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">const a;</div><div class="line">console.log(a);//报错</div></pre></td></tr></table></figure></p>
<p><code>const</code>与<code>let</code>一样，只在声明所在的会计作用域内有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if(true)&#123;</div><div class="line">    const a = 5;</div><div class="line">    console.log(a);//5</div><div class="line">&#125;</div><div class="line">console.log(a);//报错</div></pre></td></tr></table></figure></p>
<p><code>const</code>命令声明的常量也不能提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(true)&#123;</div><div class="line">    console.log(a);</div><div class="line">    const a = 1;//报错</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>const</code>声明的常量和<code>let</code>一样补课重复声明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var a = 1;</div><div class="line">let b = 2;</div><div class="line"></div><div class="line">//以下两行代码都会报错</div><div class="line">const a = 3;</div><div class="line">const b = 4;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p><code>const</code>实质上并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针,<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const foo = &#123;&#125;;</div><div class="line"></div><div class="line">//为foo添加一个属性，可以成功</div><div class="line">foo.prop = 123 ;</div><div class="line">console.log(foo.prop);//123</div><div class="line">//将foo指向另外一个对象，就会报错</div><div class="line">foo = &#123;&#125;;//报错</div></pre></td></tr></table></figure></p>
<p>上面代码中，常量<code>foo</code>储存的是一个地址。这个地址指向一个对象，不变的只是这个地址，既不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const a = [];</div><div class="line">a.push(&apos;Hello&apos;);//可执行</div><div class="line">a.length = 0;//可执行</div><div class="line">a = [&apos;world&apos;];//报错</div></pre></td></tr></table></figure></p>
<p>以上代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>,就会报错。<br>如果真想将对象冻结，应使用<code>Object.freeze</code>方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const foo = Object.freeze(&#123;&#125;);</div><div class="line">//常规模式下，下面一行不起作用；</div><div class="line">//严格模式下，该行会报错；</div><div class="line">foo.prop = 123;</div></pre></td></tr></table></figure></p>
<p>以上代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式下还会报错。   </p>
<p>除了对象本身冻结之外，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var constantize = (obj) =&gt; &#123;</div><div class="line">  Object.freeze(obj);</div><div class="line">  Object.keys(obj).forEach( (key, i) =&gt; &#123;</div><div class="line">    if ( typeof obj[key] === &apos;object&apos; ) &#123;</div><div class="line">      constantize( obj[key] );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="let和const的区别"><a href="#let和const的区别" class="headerlink" title="let和const的区别"></a><code>let</code>和<code>const</code>的区别</h1><p><code>const</code>声明的常量需要立即赋值，否则就会报错。而且一旦声明的常量，就不可再改变其值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;const命令&quot;&gt;&lt;a href=&quot;#const命令&quot; class=&quot;headerlink&quot; title=&quot;const命令&quot;&gt;&lt;/a&gt;const命令&lt;/h1&gt;&lt;h2 id=&quot;1-基本用法&quot;&gt;&lt;a href=&quot;#1-基本用法&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="const" scheme="http://yoursite.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-第一篇(let命令和块级作用域)</title>
    <link href="http://yoursite.com/2017/06/02/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://yoursite.com/2017/06/02/ES6学习笔记-第一篇/</id>
    <published>2017-06-02T02:35:24.000Z</published>
    <updated>2017-06-02T06:22:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：按照自己的学习计划，先巩固JS基础，然后学习一个框架，之后再学习ES6。<br>4月份参加一个面试，面试官问我懂不懂ES6，我和他说了我的规划。面试官说，学习JS和学习框架都不影响你同时学习ES6。听了面试官的一番话之后，我觉得确实是自己懒散了。在学习其他语言的时候并不影响我学习ES6，甚至能够帮助我更好的运用ES6，4、5月一直忙毕业的事，现在学校的事情告一段落，终于有时间来填这个坑了。<br>注：ES6学习参考阮一峰老师写的<a href="http://es6.ruanyifeng.com/#docs/" target="_blank" rel="external">ES6文档</a>。</p>
<hr>
<p>1.let命令<br>基本用法：<code>let</code>命令用来声明变量，用法类似于<code>var</code>。和<code>var</code>声明变量不同的是，<code>let</code>命令只在所在的代码块内有效。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    let a = 1;</div><div class="line">    let b = 2;</div><div class="line">&#125;</div><div class="line">a //报错</div><div class="line">b //1</div></pre></td></tr></table></figure></p>
<p>以上代码，在代码块内声明了a,b两个变量。然后在代码块外调用这两个变量，调用a报错，但是调用b正常。这表明，<code>let</code>声明的变量只在它的代码块的区域内有效。<br><code>for</code>循环很适合用let命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(let i = 0;i &lt; 3;i++)&#123;</div><div class="line">    console.log(&quot;FOR:&quot;+i);//FOR:0; FOR:1; FOR:2;</div><div class="line">&#125;</div><div class="line">console.log(i);//报错</div></pre></td></tr></table></figure></p>
<p>以上代码，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外就会报错；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var a = [];</div><div class="line">for(var i=0;i&lt;3;i++)&#123;</div><div class="line">    a[i] = function()&#123;</div><div class="line">        console.log(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[2]();//3</div><div class="line"></div><div class="line">var b = [];</div><div class="line">for(let j=0;i&lt;3;j++)&#123;</div><div class="line">    b[j]=function()&#123;</div><div class="line">        console.log(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">b[2]();//2</div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>a</code>是<code>var</code>声明的，是全局变量。由于<code>for</code>循环不是块级作用域，因此<code>i</code>也是全局变量。每一次循环，<code>i</code>的值都会改变，而循环内被赋给数组<code>a</code>的<code>function</code>在运行时，会通过闭包读到这同一个变量<code>i</code>，导致最后输出的是最后一轮<code>i</code>的值为3；<br>而下面一个<code>for</code>循环使用<code>let</code>声明i，这个i的只在<code>for</code>循环中有效，且这个<code>i</code>只在每一轮中有效，每循环一次都是一个新的<code>i</code>。<br>注：在这里，JavaScript引擎内部会记住上一轮循环的值，初始化本轮变量<code>i</code>时，就在上一轮循环的基础上进行计算。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(let i = 0;i &lt; 3;i++)&#123;</div><div class="line">    let = &apos;abc&apos;;</div><div class="line">    console.log(i);</div><div class="line">&#125;</div><div class="line">//abc</div><div class="line">//abc</div><div class="line">//abc</div></pre></td></tr></table></figure>
<p>以上代码最后输出了三次<code>abc</code>，这表明函数内部的变量<code>i</code>不同于循环变量<code>i</code>，有自己单独的作用域。<br>注：<code>for</code>循环设置循环变量<code>i</code>是一个父作用域，而循环内部是一个单独的子作用域。  </p>
<hr>
<h1 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//var声明的变量</div><div class="line">console.log(a);//undefined</div><div class="line">var a = 1;</div><div class="line"></div><div class="line">//let声明的变量</div><div class="line">console.log(b);//报错</div><div class="line">let b = 2;</div></pre></td></tr></table></figure>
<hr>
<h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var tmp = 123;</div><div class="line">if(true)&#123;</div><div class="line">    tmp = &apos;abc&apos;//报错</div><div class="line">    let tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码，尽管在<code>if</code>之前已经用<code>var</code>声明了<code>tmp</code>，但是在<code>if</code>的作用域内又用<code>let</code>声明了<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量之前，对<code>tmp</code>赋值会报错。<br>** ES6明确规定，如果在区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function fn(x = y,y= 2)&#123;</div><div class="line">    return [x,y];</div><div class="line">&#125;</div><div class="line">fn();//报错</div><div class="line"></div><div class="line">var x = x;//不报错</div><div class="line"></div><div class="line">let x = x;//报错</div></pre></td></tr></table></figure>
<hr>
<h1 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h1><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//报错</div><div class="line">function ()&#123;</div><div class="line">    let a =1;</div><div class="line">    var a=2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//报错</div><div class="line">function ()&#123;</div><div class="line">    let a =1;</div><div class="line">    let a=2;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fn(b)&#123;</div><div class="line">    let b;//报错</div><div class="line">&#125;</div><div class="line">function fn(b)&#123;</div><div class="line">    &#123;</div><div class="line">        let b;//不报错</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><p><code>let</code>实际上为JS新增了块级作用域。<br>1.ES6允许块级作用域任意嵌套。<br>2.外层作用域无法读取内层作用域的变量；<br>3.内层作用域可以定义外层作用域的同名变量。<br>4.块级作用域的出现，可以取代立即执行函数。<br>5.可以在块级作用域中声明函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line">    let a =1;</div><div class="line">    if(true)&#123;</div><div class="line">        let a = 2;</div><div class="line">    &#125;</div><div class="line">    console.log(a);//1</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;&#123;&#123;</div><div class="line">    let b = 2;</div><div class="line">    &#123;let b = 3;&#125;</div><div class="line">&#125;&#125;&#125;</div><div class="line"></div><div class="line">//立即执行函数</div><div class="line">(function()&#123;</div><div class="line">    var tmp = ...;</div><div class="line">    ...</div><div class="line">&#125;)()</div><div class="line"></div><div class="line">&#123;</div><div class="line">    let tmp = ...;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h1><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    let a = f();</div><div class="line">    a = a * a + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到<code>a</code>的值，因为块级作用域没有返回值，除非<code>a</code>是全局变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">let x = do&#123;</div><div class="line">    let a = f();</div><div class="line">    a * a + 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>x</code>会得到整个块级作用域的返回值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：按照自己的学习计划，先巩固JS基础，然后学习一个框架，之后再学习ES6。&lt;br&gt;4月份参加一个面试，面试官问我懂不懂ES6，我和他说了我的规划。面试官说，学习JS和学习框架都不影响你同时学习ES6。听了面试官的一番话之后，我觉得确实是自己懒散了。在学习其他语言的时候并
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="let" scheme="http://yoursite.com/tags/let/"/>
    
      <category term="块级作用域" scheme="http://yoursite.com/tags/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建GitHub博客填坑指南</title>
    <link href="http://yoursite.com/2017/06/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/06/01/使用hexo搭建GitHub博客填坑指南/</id>
    <published>2017-06-01T03:52:40.000Z</published>
    <updated>2017-06-02T02:50:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>在得知hexo可以快速搭建博客之后，终于在端午假期回公司之后的第一天把这个坑给填了。下面就来写一下我用hexo搭建这个博客的过程。</p>
<hr>
<h1 id="前提-GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；"><a href="#前提-GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；" class="headerlink" title="前提:GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；"></a>前提:GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；</h1><p>GitHub注册也很简单，登录<a href="https://github.com/" target="_blank" rel="external">GitHub</a>,然后点击右侧的注册、填入相应的信息即可。<br>如何在本地创建SSH秘钥和GitHub连接，可以参考这篇文章：<a href="http://www.jianshu.com/p/31cbbbc5f9fa/" target="_blank" rel="external">http://www.jianshu.com/p/31cbbbc5f9fa/</a></p>
<h1 id="一、创建GitHub仓库"><a href="#一、创建GitHub仓库" class="headerlink" title="一、创建GitHub仓库"></a>一、创建GitHub仓库</h1><p>注：GitHub为用户提供项目链接，每个用户可以生成唯一的GitHub个人链接，这个唯一的表示一个账号只能有一个URL。这个URL的格式是<code>your-name.github.io</code><br></p>
<h1 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h1><p>进入<a href="https://nodejs.org/en/" target="_blank" rel="external">node官网</a>下载node,然后按照提示安装即可；</p>
<h1 id="三、安装git"><a href="#三、安装git" class="headerlink" title="三、安装git"></a>三、安装git</h1><p>1.进入<a href="https://git-scm.com/downloads" target="_blank" rel="external">git官网</a>下载最新版本的git,下载完成后按照提示进行安装。</p>
<h1 id="四、安装hexo"><a href="#四、安装hexo" class="headerlink" title="四、安装hexo"></a>四、安装hexo</h1><p>注：前面安装node.js和git是为安装hexo做一个铺垫，hexo安装才是最重要的。<br>1.打开命令行（window在菜单栏输入cmd），在本地创建一个项目文件夹作为博客存放文件的地址。</p>
<blockquote>
<p>$ cd 项目目录</p>
</blockquote>
<p>注：项目目录可以使用拖拽的方式将项目的文件夹拖到命令行中即可；<br>2.使用npm安装hexo</p>
<blockquote>
<p>$ npm install -g hexo-cli</p>
</blockquote>
<p>3.安装好之后输入hexo检查是否安装成功</p>
<blockquote>
<p>$ hexo</p>
</blockquote>
<p>注：如果出现以下图中代码，则说明安装成功</p>
<p>4.初始化博客</p>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>5.在项目下安装npm</p>
<blockquote>
<p>$ npm install<br>注：在安装好npm和初始化博客文件之后，在博客的文件夹下面会生成很多文件。   </p>
</blockquote>
<p>6.配置博客<br> 1）打开本地博客文件夹里面的<code>_config.yml_</code>,设置博客的一些基础信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: Isrenx   </div><div class="line">subtitle: 在这里记录学习轨迹、记录生活。   </div><div class="line">description: Stay hungry,Stay foolish!   </div><div class="line">author: Victor   </div><div class="line">language: zh-Hans   </div><div class="line">timezone: Asia/Shanghai</div></pre></td></tr></table></figure></p>
<p>1.其中的timezone是设置时区，其中中国区的都要设置<code>Asia/Shanghai</code>,因为根据时区的设计规则，中国区的时区是按照这个形式来指明的，切忌不要把shanghai改成beijing或者其他地区的名字，否则就会在后面添加文章的时候出错。<br>2.<code>language</code>是设置博客的语言，一般中文用<code>zh-CN</code>,这里我用的<code>zh-Hans</code>是因为我用的next主题的中文设置是这个。<br>注：所有的<code>_config.yml_</code>中的设置，冒号：后面都要输入一个空格再加上设置的内容，否则会报错。</p>
<h5 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR Process failed: _posts/firstdemo.md</div><div class="line">TypeError: Cannot read property &apos;offset&apos; of null</div><div class="line">at Object.exports.timezone (/Users/victor/Desktop/workplace/IsrenxBlog/node_modules/hexo/lib/plugins/processor/common.js:44:40)</div></pre></td></tr></table></figure>
<p>注：如果是报上面这种错误，则说明是timezone设置错误，时区一定要设置正确，中国区必须是<code>Asia/Shanghai</code></p>
<p>7.配置部署，与GitHub对应<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/Isrenx/Isrenx.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>其中repo后面输入你之前建好的仓库地址。。<br>仓库地址可以如下位置中找到：</p>
<p>8.在本地查看博客是否搭建成功</p>
<blockquote>
<p>$ hexo clean #清楚之前的文件     </p>
<p>$ hexo g #更新项目下的修改文件    </p>
<p>$ hexo s #生成本地的链接    </p>
</blockquote>
<p>运行以上命令之后进入浏览器访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>,如果出现hexo的博客页面，则说明搭建成功。   </p>
<p>9.复制主题</p>
<blockquote>
<p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</blockquote>
<p>10.启用next主题<br>打开你的博客文件夹根目录下面的<code>_config.yml_</code>，找到themes，修改成next。这样就代表启用next主题，以后切换成其他主题也要在这里进行修改。</p>
<p>11.自定义博客<br>打开博客所在的文件夹下面的themes–&gt;next–&gt;.config.yml<br>根据<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">next主题官网</a>中的说明修改此文件中的代码来自定义自己的博客。<br>注：因为next官网中对于各个部分都介绍的很详细，所以我就不赘述了，大家可以看官网跟着操作就行。    </p>
<p>12.将本地的博客主题文件push到GitHub上   </p>
<blockquote>
<p>cd themes/next<br>git pull     </p>
</blockquote>
<p>13.将生成的其他文件上传到GitHub   </p>
<blockquote>
<p>$ cd 博客文件夹根目录<br>$ hexo clean<br>$ hexo -g d    </p>
</blockquote>
<h3 id="至此，博客已经搭建完成。访问https-your-name-github-io-即可访问你的博客。"><a href="#至此，博客已经搭建完成。访问https-your-name-github-io-即可访问你的博客。" class="headerlink" title="至此，博客已经搭建完成。访问https://your-name.github.io/  即可访问你的博客。"></a>至此，博客已经搭建完成。访问<a href="https://your-name.github.io/" target="_blank" rel="external">https://your-name.github.io/</a>  即可访问你的博客。</h3><h1 id="五、发表文章"><a href="#五、发表文章" class="headerlink" title="五、发表文章"></a>五、发表文章</h1><p>1.在命令行中通过cd进入博客文件夹，然后在命令行中输入：</p>
<blockquote>
<p>$ hexo new “文章名称”   </p>
</blockquote>
<p>执行这个命令就在根目录下的source的_posts文件夹下面创建了一个md文件，通过在这个md文件里面使用markdown语法写文章即可。写好后的文章执行以下命令上传到GitHub：    </p>
<blockquote>
<p>$ hexo clean<br>$ hexo -g d </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在得知hexo可以快速搭建博客之后，终于在端午假期回公司之后的第一天把这个坑给填了。下面就来写一下我用hexo搭建这个博客的过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前提-GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；&quot;&gt;&lt;a href=&quot;#前提-Gi
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>第一篇hexo博客，关于我，关于园子。</title>
    <link href="http://yoursite.com/2017/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87hexo%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%85%B3%E4%BA%8E%E6%88%91%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%9B%AD%E5%AD%90%E3%80%82/"/>
    <id>http://yoursite.com/2017/06/01/第一篇hexo博客，关于我，关于园子。/</id>
    <published>2017-06-01T03:13:28.000Z</published>
    <updated>2017-06-01T03:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　一直想有一个自己的博客，之前了解到可以通过WordPress来搭建一个比较完整的博客。看过一些文档，感觉用WordPress搭建博客实在太麻烦，以前也不太会使用GitHub，这个想法就搁置了。<br>　　在写文字这件事上，我不是一个勤劳的人。也不知道自己怎么慢慢的变成了这样，明明高中是靠写文字在成绩单有一些亮点。很早之前在学长的熏陶下在博客园建了一个博客，偶尔想起来的时候会在上面记录一些前端学习过程中的笔记。我是一个不太喜欢麻烦事情的人，用博客园写文章也稍显麻烦。所以我的学习笔记基本上都是写在我的为知笔记里面，而且为知笔记的同步功能也特别实用。<br>　　今年2月底的时候去了新公司之后，师兄看到我用为知做笔记，他建议我将笔记写到网上，分享给别人的同时也让大家帮忙鉴错。有时候自己写的笔记可能存在错误，如果没人发现就会一直错下去。之后又看到师兄他的博客，就请教了一下他用什么搭建的博客。在师兄的意见和自己的查阅资料之后，了解到可以用GitHub和hexo结合起来做一个简单的博客。<br>　　在新公司，任务不多，自己的学习时间就多了许多。利用这段期间开始学习Vue，学到想睡觉的时候就看看搭建博客的资料。最后，在答辩完回来上班之后的第一天把博客搭建好了。这中间遇到了很多坑，在爬坑的过程中又了解到了很多新的知识，终于觉得自己是一个程序猿了。<br>　　之后会把搭建博客的流程写一篇文章放上来，尽管用hexo搭建博客的文章比比皆是，我还是写一篇记录一下自己这个过程，也是整理自己的思路。也希望能够帮助到别人。<br>　　这个博客以后主要是记录自己在前端学习过程中遇到的一些问题和学习笔记，同时也会记录自己的一些生活，比如看书的心得、电影的影评、生活感悟之类的。总之，希望这个博客能够留下自己学习和生活的轨迹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　一直想有一个自己的博客，之前了解到可以通过WordPress来搭建一个比较完整的博客。看过一些文档，感觉用WordPress搭建博客实在太麻烦，以前也不太会使用GitHub，这个想法就搁置了。&lt;br&gt;　　在写文字这件事上，我不是一个勤劳的人。也不知道自己怎么慢慢的变成了
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
