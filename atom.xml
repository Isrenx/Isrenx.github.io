<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Isrenx</title>
  <subtitle>在这里记录学习轨迹、记录生活。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-06-14T10:29:19.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Victor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES6学习笔记-第四篇(数组的扩展)</title>
    <link href="http://yoursite.com/2017/06/13/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AF%87-%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/06/13/ES6学习笔记-第四篇-数组的扩展/</id>
    <published>2017-06-13T07:01:10.000Z</published>
    <updated>2017-06-14T10:29:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h1><p><code>Array.from()</code>将类似数组(arrayLike)的对象和可遍历的对象(包括ES6新增的数据结构<code>Set</code>和<code>Map</code>)这两类对象转换成真正的数组。  </p>
<h2 id="类似数组"><a href="#类似数组" class="headerlink" title="类似数组"></a>类似数组</h2><p>在实际应用中，常见的类似数组的对象是DOM操作返回的Nodelist集合，以及函数内部的<code>arguments</code>对象。<br><strong>类似数组对象，本质特征只有一点，就是必须有<code>length</code>属性，这也是为什么能使用<code>Array.from()</code>将它转化为数组的原因；</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> arr =&#123;</div><div class="line">        <span class="string">'0'</span>:<span class="string">'a'</span>,</div><div class="line">        <span class="string">'1'</span>:<span class="string">'b'</span>,</div><div class="line">        <span class="string">'2'</span>:<span class="string">'c'</span>,</div><div class="line">        <span class="attr">length</span>:<span class="number">3</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> str = <span class="built_in">Array</span>.from(arr);</div><div class="line">    <span class="built_in">console</span>.log(str);</div><div class="line">    <span class="comment">// ES5的写法</span></div><div class="line">    <span class="keyword">var</span> arr1 = [].slice.call(arr); <span class="comment">// ['a', 'b', 'c']</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// NodeList对象</span></div><div class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</div><div class="line"><span class="built_in">Array</span>.from(ps).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(p);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// arguments对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用<code>forEach</code>方法。  </p>
<h2 id="使用Array-from-的前提条件"><a href="#使用Array-from-的前提条件" class="headerlink" title="使用Array.from()的前提条件"></a>使用<code>Array.from()</code>的前提条件</h2><p>1.部署了<code>Iterator</code>接口的数据结构;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(<span class="string">'victor'</span>)</div><div class="line"><span class="comment">// ['v', 'i', 'c', 't', 'o','r']</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>])</div><div class="line"><span class="built_in">Array</span>.from(namesSet) <span class="comment">// ['a', 'b']</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，字符串和<code>Set</code>结构都具有<code>Iterator</code>接口，因此可以被<code>Array.from</code>转为真正的数组。<br><strong>扩展</strong><br>使用<code>...</code>扩展运算符也可以将某些数据结构转换为数组；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// arguments对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> args = [...arguments];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// NodeList对象</span></div><div class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</div></pre></td></tr></table></figure></p>
<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<br>但是<code>...</code>扩展运算符有局限性，它对有<code>length</code>属性的类似数组对象不能转为数组；  </p>
<p>2.任何有<code>length</code>属性的对象；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</div><div class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Array.from</code>返回了一个具有三个成员的数组，每个位置的值都是<code>undefined</code>。扩展运算符转换不了这个对象。  </p>
<p>对于还没有部署该方法的浏览器，可以用<code>Array.prototype.slice</code>方法替代。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> toArray = <span class="function">(<span class="params">(</span>) =&gt;</span></div><div class="line">  <span class="built_in">Array</span>.from ? <span class="built_in">Array</span>.from : <span class="function"><span class="params">obj</span> =&gt;</span> [].slice.call(obj)</div><div class="line">)();</div></pre></td></tr></table></figure></p>
<h2 id="Array-from-其他用法"><a href="#Array-from-其他用法" class="headerlink" title="Array.from()其他用法"></a><code>Array.from()</code>其他用法</h2><p>1.如果参数是一个数组，结果还是返回一个数组；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]);<span class="comment">//['a','b','c']</span></div></pre></td></tr></table></figure></p>
<p>2.<code>Array.from()</code>还能接受第二个参数，作用类似于数组的<code>map</code>方法，用于对每个元素进行处理，将处理后的值放入返回的结果数组；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(arrayLike, x =&gt; x * x);</div><div class="line"><span class="comment">// 等同于</span></div><div class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</div><div class="line"></div><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], (x) =&gt; x * x)</div><div class="line"><span class="comment">// [1, 4, 9]</span></div></pre></td></tr></table></figure></p>
<p>eg:将数组中布尔值为<code>false</code>的值换为<code>0</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], (n) =&gt; n || <span class="number">0</span>)</div><div class="line"><span class="comment">// [1, 0, 2, 0, 3]</span></div></pre></td></tr></table></figure></p>
<p>eg:返回各种数据的类型；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, value =&gt; <span class="keyword">typeof</span> value)</div><div class="line">&#125;</div><div class="line">typesOf(<span class="literal">null</span>, [], <span class="literal">NaN</span>)</div><div class="line"><span class="comment">// ['object', 'object', 'number']</span></div></pre></td></tr></table></figure></p>
<p>如果<code>map</code>函数里面用到了<code>this</code>，<code>Array.from()</code>还可传入第三个参数用来绑定<code>this</code>;  </p>
<p>3.<code>Array.from()</code>可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">2</span> &#125;, () =&gt; <span class="string">'jack'</span>)</div><div class="line"><span class="comment">// ['jack', 'jack']</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>length</code>制定了第二个参数运行的次数；<br>4.<code>Array.from()</code>还可将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(string).length;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a>Array.of()</h1><p><code>Array.of()</code>是将一组值转换为数组；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//[1,2,3]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>);<span class="comment">//[1]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>).length;<span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>在ES6之前的<code>Array()</code>方法中，因为函数参数的不同会导致<code>Array()</code>有不同的差异，如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">2</span>);<span class="comment">//[,]</span></div><div class="line"><span class="built_in">Array</span>();<span class="comment">//[]</span></div><div class="line"><span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="comment">//[1,2,3]</span></div></pre></td></tr></table></figure></p>
<p>在<code>Array()</code>中，只有一个参数时，<code>Array()</code>内部将第一个参数当做传入的值的<code>length</code>；只有当参数个数大于等于2的时候才是将参数转换为数组；<br><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>,并且不存在由于参数不同而导致的重载。它的行为非常统一。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></div><div class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></div></pre></td></tr></table></figure></p>
<h1 id="数组实例的copyWithin方法"><a href="#数组实例的copyWithin方法" class="headerlink" title="数组实例的copyWithin方法"></a>数组实例的copyWithin方法</h1><p>数组实例的<code>copyWithin(target,start,end)</code>方法是在当前数组内部，根据参数<code>start</code>(从start开始)和(到end结束)两个值的设定，将设定位置的值复制到其他位置。<br><strong>复制的值会覆盖原有位置的值</strong><br>它接受三个参数：</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br><strong>这三个参数必须是数值，如果不是数值将会转换为数值再进行复制</strong>  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</div><div class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 将3号位复制到0号位</span></div><div class="line">[].copyWithin.call(&#123;<span class="attr">length</span>: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</div><div class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></div><div class="line"></div><div class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></div><div class="line"><span class="keyword">var</span> i32a = <span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</div><div class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></div><div class="line"></div><div class="line"><span class="comment">// 对于没有部署TypedArray的copyWithin方法的平台</span></div><div class="line"><span class="comment">// 需要采用下面的写法</span></div><div class="line">[].copyWithin.call(<span class="keyword">new</span> <span class="built_in">Int32Array</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</div><div class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure></p>
<h1 id="数组实例的find-和findIndex-方法"><a href="#数组实例的find-和findIndex-方法" class="headerlink" title="数组实例的find()和findIndex()方法"></a>数组实例的find()和findIndex()方法</h1><p><code>find()</code>:找出数组中第一个符合条件的值；<br>注：它的参数是一个回调函数，数组里面所有的值都要依次执行该回调函数，直到找到第一个返回值为<code>true</code>的值才结束，然后返回此时的值；如果没有符合条件的值，则返回<code>undefined</code>;<br>eg:找出数组中小于3的第一个值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].find( <span class="function">(<span class="params">n</span>) =&gt;</span> n&lt;<span class="number">3</span> );<span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p><code>find()</code>方法的回调函数能接受三个参数，依次为当前的值，当前值得位置和原数组；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</div><div class="line">&#125;) <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p><code>findIndex()</code>:返回第一个符合条件的值所在的位置；<br>注：如果所有条件都不符合，返回<code>-1</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</div><div class="line">&#125;) <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>另外这两个方法都可以接受第二个参数，用来绑定回调函数的<code>this</code>对象；这两个方法还能找出<code>Nan</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</div><div class="line"><span class="comment">// -1</span></div><div class="line"></div><div class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</div><div class="line"><span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<h1 id="数组实例的fill-方法"><a href="#数组实例的fill-方法" class="headerlink" title="数组实例的fill()方法"></a>数组实例的fill()方法</h1><p><code>fill()</code>方法使用给定值，填充指定的数组，但是会覆盖之前的数组；一般用来初始化数组比较好；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].fill(<span class="string">'a'</span>);<span class="comment">//['a','a','a']</span></div></pre></td></tr></table></figure></p>
<p><code>fill()</code>方法可以传入三个参数，第一个参数为填充的值，第二个参数是填充值的开始位置，第三个参数是填充值得结束位置；通过后面两个参数，能够制定覆盖哪些数组的值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>].fill(<span class="string">'a'</span>,<span class="number">2</span>,<span class="number">4</span>);<span class="comment">//[1,2,'a','a',5,6];</span></div></pre></td></tr></table></figure></p>
<h1 id="数组实例的entries-keys-values-方法"><a href="#数组实例的entries-keys-values-方法" class="headerlink" title="数组实例的entries()/keys()/values()方法"></a>数组实例的entries()/keys()/values()方法</h1><p><code>entries()</code>/<code>keys()</code>/<code>values()</code>这三个方法是ES6新增用来遍历数组的，它们都返回一个遍历器对象，可以用<code>for...of</code>遍历；<br><code>entries()</code>是对键值对的遍历；<code>keys()</code>是对键名的遍历；<code>values()</code>是对键值的遍历；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 'a'</span></div><div class="line"><span class="comment">// 'b'</span></div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</div><div class="line">  <span class="built_in">console</span>.log(index, elem);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 0 "a"</span></div><div class="line"><span class="comment">// 1 "b"</span></div></pre></td></tr></table></figure></p>
<p><strong>在最新版的chrome中，调用console测试<code>values()</code>方法，报错；但是其他两个方法都能正常使用；以上<code>values()</code>方法的返回结果是在支持该方法中的浏览器中返回的结果</strong><br>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</div><div class="line"><span class="keyword">let</span> entries = letter.entries();</div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></div><div class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></div></pre></td></tr></table></figure></p>
<h1 id="数组的实例includes-方法"><a href="#数组的实例includes-方法" class="headerlink" title="数组的实例includes()方法"></a>数组的实例includes()方法</h1><p><code>includes()</code>:表示某个数组是否包含指定的值，如包含则返回<code>true</code>，否则返回<code>false</code>;<br><code>includes(value,start)</code>第一个参数<code>value</code>表示查询的值，<code>start</code>表示查询的起始位置；如果<code>start</code>为负数，则表示倒数位置，如果<code>start</code>大于数组长度，则会重置为从<code>0</code>开始；第二个参数可选；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].includes(<span class="number">2</span>);<span class="comment">//true</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].includes(<span class="number">4</span>,<span class="number">2</span>);<span class="comment">//true</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].includes(<span class="number">2</span>,<span class="number">-2</span>);<span class="comment">//false</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].includes(<span class="number">4</span>,<span class="number">-2</span>);<span class="comment">//true</span></div><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>在ES6之前，查找某个数组是否包含指定的值使用<code>indexOf()</code>;<br><code>indexOf</code>方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h1><p>数组的空位是指：数组某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>(<span class="number">3</span>);<span class="comment">//[ , , ]</span></div></pre></td></tr></table></figure></p>
<p><strong>空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>还是有值得，而空位是没有任何值的。<code>in</code>运算符可以证明这一点</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>,<span class="literal">undefined</span>,<span class="literal">undefined</span>];<span class="comment">//true</span></div><div class="line"><span class="number">0</span> <span class="keyword">in</span> [ , , , ]; <span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。  </p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。  </li>
<li><code>map()</code>会跳过空位，但会保留这个值  </li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// forEach方法</span></div><div class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// filter方法</span></div><div class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></div><div class="line"></div><div class="line"><span class="comment">// every方法</span></div><div class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// some方法</span></div><div class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="comment">// map方法</span></div><div class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></div><div class="line"></div><div class="line"><span class="comment">// join方法</span></div><div class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></div><div class="line"></div><div class="line"><span class="comment">// toString方法</span></div><div class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>而ES6则是明确将空位转为<code>undefined</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Array</span>.from([<span class="string">'a'</span>,,<span class="string">'b'</span>])</div><div class="line"><span class="comment">// [ "a", undefined, "b" ]</span></div><div class="line"></div><div class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</div><div class="line"><span class="comment">// [ "a", undefined, "b" ]</span></div><div class="line"></div><div class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,"a",,"a"]</span></div><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> arr = [, ,];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// entries()</span></div><div class="line">[...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></div><div class="line"></div><div class="line"><span class="comment">// keys()</span></div><div class="line">[...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></div><div class="line"></div><div class="line"><span class="comment">// values()</span></div><div class="line">[...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></div><div class="line"></div><div class="line"><span class="comment">// find()</span></div><div class="line">[,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></div><div class="line"></div><div class="line"><span class="comment">// findIndex()</span></div><div class="line">[,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></div></pre></td></tr></table></figure></p>
<p><strong>由于空位的处理规则非常不统一，所以建议避免出现空位。</strong>  </p>
<p>以上文章主要参考阮一峰老师的ES6学习指南：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Array-from&quot;&gt;&lt;a href=&quot;#Array-from&quot; class=&quot;headerlink&quot; title=&quot;Array.from()&quot;&gt;&lt;/a&gt;Array.from()&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Array.from()&lt;/code&gt;将类似数组(arr
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="数组的扩展" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-第三篇(字符串和变量的扩展)</title>
    <link href="http://yoursite.com/2017/06/09/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95/"/>
    <id>http://yoursite.com/2017/06/09/ES6学习笔记-第三篇-字符串和变量的扩展/</id>
    <published>2017-06-09T09:36:13.000Z</published>
    <updated>2017-06-14T10:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值扩展"><a href="#数值扩展" class="headerlink" title="数值扩展"></a>数值扩展</h1><h2 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1.二进制和八进制表示法"></a>1.二进制和八进制表示法</h2><p>ES6提供了新的二进制和八进制的写法，规定二进制前缀使用<code>0b</code>或<code>0B</code>，八进制使用<code>0o</code>或<code>0O</code>表示；从ES5开始，严格模式就规定八进制不能再使用<code>0</code>表示。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></div><div class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>二进制、八进制转化成十进制使用<code>Number()</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>(<span class="string">'0b111'</span>)  <span class="comment">// 7</span></div><div class="line"><span class="built_in">Number</span>(<span class="string">'0o10'</span>)  <span class="comment">// 8</span></div></pre></td></tr></table></figure></p>
<h2 id="2-ES6在Number上新增的方法；"><a href="#2-ES6在Number上新增的方法；" class="headerlink" title="2.ES6在Number上新增的方法；"></a>2.ES6在<code>Number</code>上新增的方法；</h2><ul>
<li><p>1）<code>Number.isFinite()</code>用来检查一个数值是否为有限的(finite);对于非数值一律返回<code>false</code>;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.isFinite(<span class="number">1</span>);<span class="comment">//true</span></div><div class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.1</span>);<span class="comment">//true</span></div><div class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isFinite(Infitity);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isFinite(-Infitity);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'string'</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'1'</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'true'</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
<li><p>2)<code>Number.isNaN()</code>用来判断值是否为<code>NaN</code>;只对<code>NaN</code>返回<code>true</code>;  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>);<span class="comment">//true</span></div><div class="line"><span class="built_in">Number</span>.isNaN(<span class="number">1</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'1'</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
<li><p>注：它们与传统全局的<code>isFinite()</code>和<code>isNaN()</code>的区别在于——传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而新方法只对数值有效。  </p>
</li>
<li><p>3)<code>Number.parseInt()</code>和<code>Number.parseFloat()</code>;<br>ES6将全局的<code>parseInt()</code>和<code>parseFloat()</code>方法移移植到<code>Number</code>对象上，行为完全保持不变；  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.parseInt(<span class="string">'123.45'</span>);<span class="comment">//123</span></div><div class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">'123.456@'</span>);<span class="comment">//123.456</span></div></pre></td></tr></table></figure>
</li>
<li><p>4)<code>Number.isInteger()</code>用来判断值是否为整数。在<code>JavaScript</code>中，整数和浮点数是同样的存储方法，3.0和3被视为同一个值；  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.isInteger(<span class="number">23</span>);<span class="comment">//true</span></div><div class="line"><span class="built_in">Number</span>.isInteger(<span class="number">23.0</span>);<span class="comment">//true</span></div><div class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'23.0'</span>);<span class="comment">//false</span></div><div class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>);<span class="comment">//false</span></div></pre></td></tr></table></figure>
</li>
<li><p>5)<code>Number.EPSILON</code>是ES6在<code>Number</code>对象上，新增的一个极小的常量。它主要是为浮点数计算，设置一个误差范围。因为浮点数计算不精确。在浮点数计算时，引用这个方法，如果计算结果误差小于<code>Number.EPSILON</code>这个常量的值，就可以认为得到了正确的结果。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.EPSILON  <span class="comment">// 2.220446049250313e-16</span></div><div class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)  <span class="comment">// '0.00000000000000022204'</span></div><div class="line"></div><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span>   <span class="comment">// 0.30000000000000004</span></div><div class="line"></div><div class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>   <span class="comment">// 5.551115123125783e-17</span></div><div class="line"></div><div class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)   <span class="comment">// '0.00000000000000005551'</span></div><div class="line"></div><div class="line"><span class="number">5.551115123125783e-17</span> &lt; <span class="built_in">Number</span>.EPSILON   <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>6)<code>Number.isSafeInteger()</code>使用它来判断值是否在<code>JavaScript</code>能够表示的范围；<br><code>JavaScript</code>能够准确表示的整数范围在<code>-2^53</code>至<code>2^52</code>之间（不含两个端点），超过这个范围，无法精确表示这个值；  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></div><div class="line"></div><div class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></div><div class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992--&gt;超出临界值的数值，计算时都用临界值来计算；</span></div><div class="line"></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>   <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>超出临界值的数值，计算时都用临界值来计算；</strong><br>ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></div><div class="line"><span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">-9007199254740991</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>从以上代码中，可以看到<code>JavaScript</code>能够精确表示的极限。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">'a'</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>因为<strong>超出临界值的数值，计算时都用临界值来计算；</strong>，因此在使用这个函数的时候，需要同时验证比较的两个值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span>)</div><div class="line"><span class="comment">// false</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">990</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</div><div class="line"><span class="comment">// true</span></div><div class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></div><div class="line"><span class="comment">// 返回结果 9007199254740002</span></div><div class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></div></pre></td></tr></table></figure></p>
<h2 id="3-Math对象上的扩展（记录常用的部分）；"><a href="#3-Math对象上的扩展（记录常用的部分）；" class="headerlink" title="3.Math对象上的扩展（记录常用的部分）；"></a>3.<code>Math</code>对象上的扩展（记录常用的部分）；</h2><ul>
<li>1)<code>Math.trunc(a)</code>用于去除<code>a</code>的小数部分，返回整数部分；  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.trunc(<span class="number">12.34</span>);<span class="comment">//12</span></div><div class="line"><span class="built_in">Math</span>.trunc(<span class="number">-12.34</span>);<span class="comment">//-12</span></div><div class="line"><span class="built_in">Math</span>.trunc(<span class="number">-0.1234</span>);<span class="comment">//-0</span></div><div class="line"><span class="built_in">Math</span>.trunc(<span class="string">'12.34'</span>);<span class="comment">//12</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于空值和无法截取整数的值，返回<code>NaN</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></div></pre></td></tr></table></figure></p>
<ul>
<li><p>2)<code>Math.sign(a)</code>用来判断<code>a</code>是正数、负数还是零。<br>它会返回五种值：</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.sign(<span class="number">-2</span>) <span class="comment">// -1</span></div><div class="line"><span class="built_in">Math</span>.sign(<span class="number">2</span>) <span class="comment">// +1</span></div><div class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></div><div class="line"><span class="built_in">Math</span>.sign(<span class="number">-0</span>) <span class="comment">// -0</span></div><div class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.sign(<span class="string">'fn'</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.sign();      <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>3)<code>Math.cbrt(a)</code>计算<code>a</code>的立方根（方法内部是先将非数值用<code>Number</code>转化为数值再计算);  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.cbrt(<span class="number">-1</span>) <span class="comment">// -1</span></div><div class="line"><span class="built_in">Math</span>.cbrt(<span class="number">0</span>)  <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.cbrt(<span class="number">1</span>)  <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.cbrt(<span class="number">2</span>)  <span class="comment">// 1.2599210498948734</span></div><div class="line"></div><div class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'8'</span>) <span class="comment">// 2</span></div><div class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'hello'</span>) <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
<li><p>4)<code>Math.fround(a)</code>返回<code>a</code>的单精度浮点数形式；  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.fround(<span class="number">0</span>)     <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.fround(<span class="number">1</span>)     <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.fround(<span class="number">1.337</span>) <span class="comment">// 1.3370000123977661</span></div><div class="line"><span class="built_in">Math</span>.fround(<span class="number">1.5</span>)   <span class="comment">// 1.5</span></div><div class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)   <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>对于整数来说，<code>Math.fround</code>方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，<code>Math.fround</code>方法会返回最接近这个小数的单精度浮点数。  </p>
<ul>
<li>5)<code>Math.hypot()</code>返回所有参数的平方和的平方根；<br>如果参数非数值，会先将参数转化为数值，只要有一个参数无法转换为数值，就会返回<code>NaN</code>;  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></div><div class="line"><span class="built_in">Math</span>.hypot();            <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.hypot(<span class="literal">NaN</span>);         <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'foo'</span>); <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="string">'5'</span>);   <span class="comment">// 7.0710678118654755</span></div><div class="line"><span class="built_in">Math</span>.hypot(<span class="number">-3</span>);          <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-对数方法"><a href="#3-对数方法" class="headerlink" title="3.对数方法"></a>3.对数方法</h2><ul>
<li><p>1)<code>Math.expm1()</code>返回(e^x)-1,即<code>Math.exp(x)-1</code>;  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.expm1(<span class="number">-1</span>) <span class="comment">// -0.6321205588285577</span></div><div class="line"><span class="built_in">Math</span>.expm1(<span class="number">0</span>)  <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.expm1(<span class="number">1</span>)  <span class="comment">// 1.718281828459045</span></div></pre></td></tr></table></figure>
</li>
<li><p>2)<code>Math.log1p()</code>返回1+x的自然对数，即<code>Math.log(1+x)</code>,如果<code>x</code>小于-1，返回<code>NaN</code>;   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.log1p(<span class="number">1</span>)  <span class="comment">// 0.6931471805599453</span></div><div class="line"><span class="built_in">Math</span>.log1p(<span class="number">0</span>)  <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.log1p(<span class="number">-1</span>) <span class="comment">// -Infinity</span></div><div class="line"><span class="built_in">Math</span>.log1p(<span class="number">-2</span>) <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
</li>
<li><p>3)<code>Math.log10()</code>返回以10为底的<code>x</code>的对数。如果<code>x</code>小于0，返回<code>NaN</code>;  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.log10(<span class="number">2</span>)      <span class="comment">// 0.3010299956639812</span></div><div class="line"><span class="built_in">Math</span>.log10(<span class="number">1</span>)      <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.log10(<span class="number">0</span>)      <span class="comment">// -Infinity</span></div><div class="line"><span class="built_in">Math</span>.log10(<span class="number">-2</span>)     <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.log10(<span class="number">100000</span>) <span class="comment">// 5</span></div></pre></td></tr></table></figure>
</li>
<li><p>4)<code>Math.log2(x)</code>返回以2为底的<code>x</code>的对数。如果<code>x</code>小于0，返回<code>NaN</code>;   </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.log2(<span class="number">3</span>)       <span class="comment">// 1.584962500721156</span></div><div class="line"><span class="built_in">Math</span>.log2(<span class="number">2</span>)       <span class="comment">// 1</span></div><div class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span>)       <span class="comment">// 0</span></div><div class="line"><span class="built_in">Math</span>.log2(<span class="number">0</span>)       <span class="comment">// -Infinity</span></div><div class="line"><span class="built_in">Math</span>.log2(<span class="number">-2</span>)      <span class="comment">// NaN</span></div><div class="line"><span class="built_in">Math</span>.log2(<span class="number">1024</span>)    <span class="comment">// 10</span></div><div class="line"><span class="built_in">Math</span>.log2(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 29</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-ES6新增的三角函数方法"><a href="#5-ES6新增的三角函数方法" class="headerlink" title="5.ES6新增的三角函数方法"></a>5.ES6新增的三角函数方法</h2><ul>
<li>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</li>
<li>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</li>
<li>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</li>
<li>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</li>
<li>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</li>
<li>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）  </li>
</ul>
<h2 id="6-指数运算符"><a href="#6-指数运算符" class="headerlink" title="6.指数运算符"></a>6.指数运算符</h2><p>ES6新增了一个指数运算符<code>**</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2</span> ** <span class="number">2</span> <span class="comment">// 4</span></div><div class="line"><span class="number">2</span> ** <span class="number">3</span> <span class="comment">// 8</span></div></pre></td></tr></table></figure></p>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符<code>**=</code>;<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">1.5</span>;</div><div class="line">a **= <span class="number">2</span>;<span class="comment">// 等同于 a = a * a;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> b = <span class="number">4</span>;</div><div class="line">b **= <span class="number">3</span>;<span class="comment">// 等同于 b = b * b * b;</span></div></pre></td></tr></table></figure></p>
<p><strong>在 V8 引擎中，指数运算符与<code>Math.pow</code>的实现不相同，对于特别大的运算结果，两者会有细微的差异;</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.pow(<span class="number">99</span>, <span class="number">99</span>)</div><div class="line"><span class="comment">// 3.697296376497263e+197</span></div><div class="line"></div><div class="line"><span class="number">99</span> ** <span class="number">99</span></div><div class="line"><span class="comment">// 3.697296376497268e+197</span></div></pre></td></tr></table></figure></p>
<p>以上代码输出的结果中，最后一位小数不同；  </p>
<h2 id="7-Math-signbit-a-判断a的正负；"><a href="#7-Math-signbit-a-判断a的正负；" class="headerlink" title="7.Math.signbit(a)判断a的正负；"></a>7.<code>Math.signbit(a)</code>判断<code>a</code>的正负；</h2><p>前面提到的<code>Math.sign()</code>也是用来判断正负的，如果参数是<code>-0</code>返回的结果也是<code>-0</code>。<code>JavaScript</code> 内部使用64位浮点数（国际标准IEEE 754）表示数值，IEEE 754规定第一位是符号位，<code>0</code>表示正数，<code>1</code>表示负数。所以会有两种零，<code>+0</code>是符号位为<code>0</code>时的零值，<code>-0</code>是符号位为<code>1</code>时的零值。实际编程中，判断一个值是<code>+0</code>还是<code>-0</code>非常麻烦，因为它们是相等的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>目前，有一个提案，引入了<code>Math.signbit()</code>方法判断一个数的符号位是否设置了。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.signbit(<span class="number">2</span>) <span class="comment">//false</span></div><div class="line"><span class="built_in">Math</span>.signbit(<span class="number">-2</span>) <span class="comment">//true</span></div><div class="line"><span class="built_in">Math</span>.signbit(<span class="number">0</span>) <span class="comment">//false</span></div><div class="line"><span class="built_in">Math</span>.signbit(<span class="number">-0</span>) <span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<p>从以上代码中我们可以看到，该方法正确返回了<code>-0</code>的符号位是设置了的。<br><strong>注：</strong>  </p>
<ul>
<li>如果参数是NaN，返回false</li>
<li>如果参数是-0，返回true</li>
<li>如果参数是负值，返回true</li>
<li>其他情况返回false  </li>
</ul>
<p>以上文章主要参考阮一峰老师的ES6学习指南：<a href="http://es6.ruanyifeng.com/" target="_blank" rel="external">http://es6.ruanyifeng.com/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数值扩展&quot;&gt;&lt;a href=&quot;#数值扩展&quot; class=&quot;headerlink&quot; title=&quot;数值扩展&quot;&gt;&lt;/a&gt;数值扩展&lt;/h1&gt;&lt;h2 id=&quot;1-二进制和八进制表示法&quot;&gt;&lt;a href=&quot;#1-二进制和八进制表示法&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="字符串扩展" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/"/>
    
      <category term="数值扩展" scheme="http://yoursite.com/tags/%E6%95%B0%E5%80%BC%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>项目填坑—H5移动端video安卓兼容、去除全屏插件、全屏</title>
    <link href="http://yoursite.com/2017/06/06/%E9%A1%B9%E7%9B%AE%E5%A1%AB%E5%9D%91%E2%80%94H5%E7%A7%BB%E5%8A%A8%E7%AB%AFvideo%E5%AE%89%E5%8D%93%E5%85%BC%E5%AE%B9%E3%80%81%E5%8E%BB%E9%99%A4%E5%85%A8%E5%B1%8F%E6%8F%92%E4%BB%B6%E3%80%81%E5%85%A8%E5%B1%8F/"/>
    <id>http://yoursite.com/2017/06/06/项目填坑—H5移动端video安卓兼容、去除全屏插件、全屏/</id>
    <published>2017-06-06T11:29:21.000Z</published>
    <updated>2017-06-14T10:33:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天接了一个H5的开发需求，中间有一段内容是以video的形式展现，PM要求video在微信中全屏显示。其实就和之前“腾讯动漫薛之谦”的H5一样~<br>在这里，我们说的全屏指的是微信中打开的页面内容可以展示的屏幕大小，不是指整个手机屏幕的全屏。因为这个理解不同，我和PM在沟通的时候出现了一些出入。<br>下面主要介绍这几个方面的问题：<br>    1.IOS全屏处理；<br>    2.安卓系统全屏处理；<br>    3.“隐藏”安卓系统默认的播放控件；</p>
<h1 id="video移动端IOS全屏处理"><a href="#video移动端IOS全屏处理" class="headerlink" title="video移动端IOS全屏处理"></a>video移动端IOS全屏处理</h1><p>1.在IOS系统下处理全屏显示并不难，只要加入相应的属性即可。需要加的属性有<code>webkit-playsinline</code>、<code>webkit-playsinline</code>、<code>x-webkit-airplay=&quot;allow&quot;</code>；<br>但是这种方法有局限，在IOS10以下的Safari不支持该属性。<br>2.第二种方法是使用第三方视频库实现。看之前薛之谦腾讯动漫H5用的是<code>iphone-inline-video.browser.js</code>。<br>使用方法：<br>    页面上引入<code>iphone-inline-video.browser.js</code>，然后调用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.querySelector(<span class="string">'video'</span>);</div><div class="line">makeVideoPlayableInline(video);</div></pre></td></tr></table></figure></p>
<p>去掉video默认居中的播放按钮使用css:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.IIV</span><span class="selector-pseudo">::-webkit-media-controls-play-button</span>,<span class="selector-class">.IIV</span><span class="selector-pseudo">::-webkit-media-controls-start-playback-button</span> &#123;</div><div class="line">   <span class="attribute">opacity</span>: <span class="number">0</span>;</div><div class="line">   <span class="attribute">pointer-events</span>: none;</div><div class="line">   <span class="attribute">width</span>: <span class="number">5px</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 注：使用第一种方法引入属性的形式，也可使用CSS的方式去掉视频中间的播放按钮。这是webkit内核浏览器支持的属性。不过<code>IIV</code>是上面插件定义的class，在不引用第三方库的时候，应写成<code>video</code>或者video标签的类名或者id选择器;   </p>
</blockquote>
<h1 id="video移动端安卓系统全屏处理"><a href="#video移动端安卓系统全屏处理" class="headerlink" title="video移动端安卓系统全屏处理"></a>video移动端安卓系统全屏处理</h1><p>安卓系统处理全屏的方式就比较恶心，因为PM不断更改需求，在这一块折腾了很久。安卓手机的全屏方式目前据我所知就两种方式。<br>1.腾讯白名单<br>这是网上普遍的一种说法。网上很多资料都显示，微信对内核浏览器做了一些升级，没在白名单内的域名，在安卓上会全屏显示，视频后面也会有一些视频推荐。<br>一直对这种说法抱着怀疑的态度，后来我把我的项目放到了公司线上的域名，也没有特殊的对待，虽然不是和薛之谦项目同一个域名，但是这个域名用处也很大，所以这种腾讯内部项目的说法有待考证。<br>2.使用CSS3的scale缩放视频<br>原理很简单：就是将视频基于某个点放大一定的倍数。<br>对于一般需要全屏的视频需求而言，最好的处理方式是从视频的中心点放大。对于视频的缩放比例也是有要求的。看了老师之前的项目，最后我选择的是根据可视区的宽高比例和视频的宽高比来判断，来确定缩放比。具体代码见下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JS</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">videoScale</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> t,i = <span class="built_in">document</span>.body.clientWidth / <span class="built_in">document</span>.body.clientHeight;</div><div class="line">          r = <span class="number">375</span> / <span class="number">667</span>;<span class="comment">//这里的比例是指视频的宽高比除2之后的数值，视频是750*1334；</span></div><div class="line">          t = i &lt; r ? <span class="built_in">document</span>.body.clientHeight / <span class="number">667</span> : <span class="built_in">document</span>.body.clientWidth / <span class="number">375</span>;</div><div class="line">          <span class="built_in">document</span>.querySelector(obj).style[<span class="string">"transform"</span>] = <span class="string">"scale("</span> + t + <span class="string">")"</span>;</div><div class="line">          <span class="built_in">document</span>.querySelector(obj).style[<span class="string">"-webkit-transform"</span>] = <span class="string">"scale("</span> + t + <span class="string">")"</span>;</div><div class="line">          <span class="built_in">document</span>.querySelector(obj).style[<span class="string">"webkit-transform-origin"</span>] = <span class="string">'center center'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//css</span></div><div class="line">video&#123;</div><div class="line">    <span class="attr">position</span>:absolute;</div><div class="line">    left:<span class="number">50</span>%;</div><div class="line">    top:<span class="number">50</span>%;</div><div class="line">    margin:<span class="number">-333</span>px <span class="number">0</span> <span class="number">0</span> <span class="number">-188</span>px;<span class="comment">//视频宽高除2之后的一半</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>video的CSS样式还需要设置<code>outline</code>、<code>appearance</code>等去除一些默认样式的属性。在这里就不一一说明了。<br><strong>注：这种方法的原理是将视频从视频的中心点放大，这就会导致一问题，视频边缘的部分被遮盖掉了。所以在使用这种方法之前，一定要让插入的视频留出一定的遮盖空间。</strong>  </p>
<h1 id="安卓手机屏幕整屏"><a href="#安卓手机屏幕整屏" class="headerlink" title="安卓手机屏幕整屏"></a>安卓手机屏幕整屏</h1><p>前面提到的安卓手机采用缩放视频的形式会遮盖视频，如果PM不想视频被遮盖，认为安卓手机屏幕全屏也可以，那便可采用屏幕全屏的形式（IOS不受影响）。<br>方法：给video标签加以下属性<br><code>x5-video-player-type=&#39;h5&#39;</code>:启用H5播放器，是微信安卓的特性；采用这种方式，安卓手机的视频会充满整个手机屏幕，播放空间会消失，但是上面有一个返回按钮和其他选项按钮。点击返回按钮退出全屏，视频也停止播放。这种方式，如果用户有过多的操作，体验就不太好，而且不是那种视频嵌入页面的设计。<br><code>x5-video-player-fullscreen=&#39;true&#39;</code>:全屏设置，设置为true是防止横屏;<br><code>x5-video-orientation=&#39;portraint&#39;</code>:播放器支持的方向，landscape横屏/portrait竖屏,默认值是横屏<br><code>object-fit:fill</code>:在安卓系统的微信里，就算加上了上面的属性，还会出现上下有黑边，不能全屏。加上这个属性就可以解决。  </p>
<p><strong>注：除了以上问题之外，关于在安卓端视频还有另外一个问题。如果视频是在后面的页面，使用的是<code>z-index</code>层级切换的方式显示隐藏视频，在首屏加载的时候，安卓手机会出现一个视频块。应该是不能用这种方法来处理。还是应该通过<code>display</code>的方式来隐藏。考虑到DOM渲染的问题，要是<code>z-index</code>能实现，外加使用增删<code>class</code>的方式是最好的，不用重新渲染页面。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;昨天接了一个H5的开发需求，中间有一段内容是以video的形式展现，PM要求video在微信中全屏显示。其实就和之前“腾讯动漫薛之谦”的H5
    
    </summary>
    
      <category term="video移动端兼容" scheme="http://yoursite.com/categories/video%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%85%BC%E5%AE%B9/"/>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
      <category term="video兼容问题" scheme="http://yoursite.com/tags/video%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-第三篇(变量的结构赋值)</title>
    <link href="http://yoursite.com/2017/06/02/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BB%93%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://yoursite.com/2017/06/02/ES6学习笔记-第三篇-变量的结构赋值/</id>
    <published>2017-06-02T07:07:19.000Z</published>
    <updated>2017-06-14T10:32:33.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组的结构赋值"><a href="#数组的结构赋值" class="headerlink" title="数组的结构赋值"></a>数组的结构赋值</h1><p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES6之前</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</div><div class="line"><span class="comment">//ES6</span></div><div class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>上面代码表示：可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p>
<p>下面是一些使用嵌套数组进行解构的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo,[[bar],baz]] = [<span class="number">1</span>,[[<span class="number">2</span>],<span class="number">3</span>]];</div><div class="line">foo;<span class="comment">//1</span></div><div class="line">bar;<span class="comment">//2</span></div><div class="line">baz;<span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [,,third] = [<span class="string">"foo"</span>,<span class="string">"bar"</span>,<span class="string">"baz"</span>];</div><div class="line">third; <span class="comment">//"baz"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x,,y] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">x; <span class="comment">//1</span></div><div class="line">y; <span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [head,...tail] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line">head;<span class="comment">//1</span></div><div class="line">tail;<span class="comment">//[2,3,4]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x,y,...z] = [<span class="string">'a'</span>];</div><div class="line">x; <span class="comment">//"a"</span></div><div class="line">y; <span class="comment">//undefined</span></div><div class="line">z; <span class="comment">//[]</span></div></pre></td></tr></table></figure></p>
<p>如果解构不成功，变量的值就为<code>undefined</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo] = [];</div><div class="line"><span class="keyword">let</span> [bar,foo] = [<span class="number">1</span>];</div><div class="line"><span class="built_in">console</span>.log(bar+<span class="string">','</span>+foo);<span class="comment">//1,undefined</span></div></pre></td></tr></table></figure></p>
<p>注：以上两种情况都属于解构不成功，<code>foo</code>的值都会等于<code>undefined</code><br>△:在等式的两边，若左边中某个值在右边对应的值是控制，则解构失败，输出undefined;若右边的值对应的左边的值不存在或为空，不报错。  </p>
<h2 id="基本用法："><a href="#基本用法：" class="headerlink" title="基本用法："></a>基本用法：</h2><p>1.可以不完全解构；即等号左边的模式，只匹配一部分的等号右边的数组；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>2.若等号右边的不是数组（严格地说，不是可遍历的结构），那么将会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</div><div class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</div><div class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</div></pre></td></tr></table></figure></p>
<p>3.<code>set</code>结构，也可以使用数组的解构赋值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</div><div class="line">x <span class="comment">// "a"</span></div></pre></td></tr></table></figure></p>
<p>4.只要数据具有<code>Iterator</code>接口，都可以采用数组形式的解构赋值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</div><div class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="keyword">yield</span> a;</div><div class="line">    [a, b] = [b, a + b];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</div><div class="line">sixth <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<p><code>Iterator</code>接口:其实就是指那些能够被遍历的数据。ES6 有一种新的遍历形式<code>for..of</code>，而<code>Iterator</code>的主要作用，就是支持此操作。<br>ESs6中有三类结构生来就具有<code>Iterator</code>接口：数组、类数组对象、Map和Set结构。  </p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>解构赋值允许指定默认值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo;<span class="comment">//true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x,y = <span class="string">"b"</span>] = [<span class="string">"a"</span>];<span class="comment">//x="a",y="b"</span></div><div class="line"><span class="keyword">let</span> [x,y = <span class="string">"b"</span>] = [<span class="string">"a"</span>,<span class="literal">undefined</span>];<span class="comment">//x="a",y="b"</span></div></pre></td></tr></table></figure></p>
<p>注：ES6内部使用严格相等运算符<code>===</code>判断一个位置是否有值。因此，如果一个数组成员不严格等于<code>undefined</code>,默认值是不会生效的。<br>以上代码中，第一个<code>y</code>因为对应右边的值为空是<code>undefined</code>,所以设置的默认值生效；第二个<code>y</code>也是如此，因为右边对应的值就是<code>undefined</code>,因此<code>y</code>就为<code>b</code>;  </p>
<h2 id="默认值的用法"><a href="#默认值的用法" class="headerlink" title="默认值的用法"></a>默认值的用法</h2><p>1.如果默认值是一个表达式，那么这个表达式是惰性求值的。即只有在用到的时候，才会求值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"aaa"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</div><div class="line">    <span class="built_in">console</span>.log(x);<span class="comment">//1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在以上代码中，因为x能够取到值，所以函数<code>f</code>根本不会执行。  </p>
<p>2.默认值可以引用解构赋值的其他变量，但该变量必须已经声明。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></div><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError</span></div></pre></td></tr></table></figure></p>
<h1 id="对象的结构赋值"><a href="#对象的结构赋值" class="headerlink" title="对象的结构赋值"></a>对象的结构赋值</h1><p>解构不仅可以用于数组，还能用于对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; foo, bar,baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>1.对象与数组解构不同点：数组的元素是按次序排列的，变量的取值由它的位置决定。而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。  </p>
<p>2.如果变量名和属性名字不一致，必须按照下面这种写法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f <span class="comment">// 'hello'</span></div><div class="line">l <span class="comment">// 'world'</span></div></pre></td></tr></table></figure></p>
<p>注：<code>foo</code>是匹配模式，<code>baz</code>才是变量。真正被赋值的是变量<code>baz</code>，而不是模式<code>foo</code>;  </p>
<p>3.<code>let</code>和<code>const</code>声明的变量，变量不能重新声明。在解构变量时也要遵守这个规则。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> foo;</div><div class="line">(&#123;foo&#125; = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;); <span class="comment">// 成功</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> baz;</div><div class="line">(&#123;<span class="attr">bar</span>: baz&#125; = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;); <span class="comment">// 成功</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>let</code>命令下面一行的圆括号是必须的。因为，解析器先解析起首的大括号，理解成一个代码块而不是赋值语句。  </p>
<p>4.解构可用于嵌套解构的对象<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">  <span class="attr">p</span>: [</div><div class="line">    <span class="string">'Hello'</span>,</div><div class="line">    &#123; <span class="attr">y</span>: <span class="string">'World'</span> &#125;</div><div class="line">  ]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</div><div class="line">x <span class="comment">// "Hello"</span></div><div class="line">y <span class="comment">// "World"</span></div></pre></td></tr></table></figure></p>
<p>注：这是的<code>p</code>是模式，不是变量，因此不会被赋值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> node = &#123;</div><div class="line">  <span class="attr">loc</span>: &#123;</div><div class="line">    <span class="attr">start</span>: &#123;</div><div class="line">      <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">      <span class="attr">column</span>: <span class="number">5</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125;&#125; &#125; = node;</div><div class="line">line <span class="comment">// 1</span></div><div class="line">loc  <span class="comment">// error: loc is undefined</span></div><div class="line">start <span class="comment">// error: start is undefined</span></div></pre></td></tr></table></figure></p>
<p>注：上面代码中，只有<code>line</code>是变量，<code>loc</code>和<code>start</code>都是模式，不会被赋值。</p>
<p>嵌套eg:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> arr = [];</div><div class="line"></div><div class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;);</div><div class="line"></div><div class="line">obj <span class="comment">// &#123;prop:123&#125;</span></div><div class="line">arr <span class="comment">// [true]</span></div></pre></td></tr></table></figure></p>
<p>5.对象也可以指定默认值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">x <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:y = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">y <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</div><div class="line">y <span class="comment">// 5</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</div><div class="line">msg <span class="comment">// "Something went wrong"</span></div></pre></td></tr></table></figure></p>
<p>6.默认值生效的条件是，对象属性值严格等于<code>undefined</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</div><div class="line">x <span class="comment">// 3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</div><div class="line">x <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>7.解构失败，变量的值等于<code>undefined</code><br>8.解构模式是嵌套的对象，而且子对象所在的浮属性不存在，就会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">'baz'</span>&#125;;</div></pre></td></tr></table></figure></p>
<p>9.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</div><div class="line">first <span class="comment">// 1</span></div><div class="line">last <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h1 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h1><p>字符串也可以解构赋值。因为，字符串被转换成了一个类似数组的对象；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// "h"</span></div><div class="line">b <span class="comment">// "e"</span></div><div class="line">c <span class="comment">// "l"</span></div><div class="line">d <span class="comment">// "l"</span></div><div class="line">e <span class="comment">// "o"</span></div></pre></td></tr></table></figure></p>
<p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div></pre></td></tr></table></figure></p>
<h1 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h1><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，数值和布尔值的包装对象都有<code>toSting</code>属性，因此变量<code>s</code>都能取到值。</p>
<p>解构赋值的规则是：只要等号右边的值不是对象或数组，就先将其转为对象。由于<code>undefined</code>和<code>null</code>无法转为对象，所以对它们进行解构赋值，都会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>; <span class="comment">// TypeError</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: y &#125; = <span class="literal">null</span>; <span class="comment">// TypeError</span></div></pre></td></tr></table></figure></p>
<h1 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h1><p>函数的参数也可以使用解构赋值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"></div><div class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>上面代码中：函数<code>add</code>的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量<code>x</code>和<code>y</code>。对于函数内部的代码来说，它们能感受到的参数是<code>x</code>和<code>y</code>.  </p>
<p>1.函数参数的结构也可以使用默认值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [x, y];</div><div class="line">&#125;</div><div class="line"></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></div><div class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></div><div class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></div><div class="line">move(); <span class="comment">// [0, 0]</span></div></pre></td></tr></table></figure></p>
<p>2.<code>undefined</code>触发函数参数的默认值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">'yes'</span></span>) =&gt;</span> x);</div><div class="line"><span class="comment">// [ 1, 'yes', 3 ]</span></div></pre></td></tr></table></figure></p>
<h1 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h1><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。  </p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。  </p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<hr>
<h2 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h2><p>1.变量声明语句，不能带圆括号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全部报错</span></div><div class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">o</span>: (&#123; <span class="attr">p</span>: p &#125;) &#125; = &#123; <span class="attr">o</span>: &#123; <span class="attr">p</span>: <span class="number">2</span> &#125; &#125;;</div></pre></td></tr></table></figure></p>
<p>注：模式不能使用圆括号；  </p>
<p>2.函数参数中（函数参数也属于变量声明），模式不能带有圆括号。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(z</span>)]) </span>&#123; <span class="keyword">return</span> z; &#125;</div></pre></td></tr></table></figure></p>
<p>3.赋值语句中，不能将整个模式或嵌套模式中的一层，放在圆括号中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 全部报错</span></div><div class="line">(&#123; <span class="attr">p</span>: a &#125;) = &#123; <span class="attr">p</span>: <span class="number">42</span> &#125;;</div><div class="line">([a]) = [<span class="number">5</span>];</div></pre></td></tr></table></figure></p>
<h2 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h2><p>1.赋值语句的非模式部分可以使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></div><div class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></div><div class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></div></pre></td></tr></table></figure></p>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><h2 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure>
<h2 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个数组</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a, b, c] = example();</div><div class="line"></div><div class="line"><span class="comment">// 返回一个对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">foo</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">bar</span>: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure>
<h2 id="函数参数定义"><a href="#函数参数定义" class="headerlink" title="函数参数定义"></a>函数参数定义</h2><p>解构赋值可以方便地将一组参数与变量名对应起来<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="提取JSON数据"><a href="#提取JSON数据" class="headerlink" title="提取JSON数据"></a>提取JSON数据</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  <span class="attr">id</span>: <span class="number">42</span>,</div><div class="line">  <span class="attr">status</span>: <span class="string">"OK"</span>,</div><div class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 42, "OK", [867, 5309]</span></div></pre></td></tr></table></figure>
<h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line">  async = true,</div><div class="line">  beforeSend = function () &#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  <span class="comment">// ... more config</span></div><div class="line">&#125;) &#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内再写<code>var foo = config.foo || &#39;default foo&#39;;</code>这样的语句。  </p>
<h2 id="遍历map结构"><a href="#遍历map结构" class="headerlink" title="遍历map结构"></a>遍历map结构</h2><p>任何部署了<code>Iterator</code>接口的对象，都可以用<code>for...of</code>循环遍历。Map结构原生支持<code>Iterator</code>接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure></p>
<p>如果只想获取键名或者只想获取键值，可以这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取键名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 获取键值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h2><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数组的结构赋值&quot;&gt;&lt;a href=&quot;#数组的结构赋值&quot; class=&quot;headerlink&quot; title=&quot;数组的结构赋值&quot;&gt;&lt;/a&gt;数组的结构赋值&lt;/h1&gt;&lt;p&gt;解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。&lt;br&gt;&lt;figu
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="变量的解构赋值" scheme="http://yoursite.com/tags/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-第二篇(const)</title>
    <link href="http://yoursite.com/2017/06/02/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AF%87-const/"/>
    <id>http://yoursite.com/2017/06/02/ES6学习笔记-第二篇-const/</id>
    <published>2017-06-02T06:22:27.000Z</published>
    <updated>2017-06-14T10:30:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a>const命令</h1><h2 id="1-基本用法"><a href="#1-基本用法" class="headerlink" title="1.基本用法"></a>1.基本用法</h2><p><code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//1</span></div><div class="line"></div><div class="line">a = <span class="number">2</span>;<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p><code>const</code>声明的变量不得改变值，这表明，<code>const</code>一旦声明变量，就必须立即初始化，不能留到以后赋值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p><code>const</code>与<code>let</code>一样，只在声明所在的会计作用域内有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="keyword">const</span> a = <span class="number">5</span>;</div><div class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//5</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p><code>const</code>命令声明的常量也不能提升，同样存在暂时性死区，只能在声明的位置后面使用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    <span class="built_in">console</span>.log(a);</div><div class="line">    <span class="keyword">const</span> a = <span class="number">1</span>;<span class="comment">//报错</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>const</code>声明的常量和<code>let</code>一样补课重复声明<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">//以下两行代码都会报错</span></div><div class="line"><span class="keyword">const</span> a = <span class="number">3</span>;</div><div class="line"><span class="keyword">const</span> b = <span class="number">4</span>;</div></pre></td></tr></table></figure></p>
<hr>
<h2 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h2><p><code>const</code>实质上并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针,<code>const</code>只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//为foo添加一个属性，可以成功</span></div><div class="line">foo.prop = <span class="number">123</span> ;</div><div class="line"><span class="built_in">console</span>.log(foo.prop);<span class="comment">//123</span></div><div class="line"><span class="comment">//将foo指向另外一个对象，就会报错</span></div><div class="line">foo = &#123;&#125;;<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，常量<code>foo</code>储存的是一个地址。这个地址指向一个对象，不变的只是这个地址，既不能把<code>foo</code>指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> a = [];</div><div class="line">a.push(<span class="string">'Hello'</span>);<span class="comment">//可执行</span></div><div class="line">a.length = <span class="number">0</span>;<span class="comment">//可执行</span></div><div class="line">a = [<span class="string">'world'</span>];<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p>以上代码中，常量<code>a</code>是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给<code>a</code>,就会报错。<br>如果真想将对象冻结，应使用<code>Object.freeze</code>方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</div><div class="line"><span class="comment">//常规模式下，下面一行不起作用；</span></div><div class="line"><span class="comment">//严格模式下，该行会报错；</span></div><div class="line">foo.prop = <span class="number">123</span>;</div></pre></td></tr></table></figure></p>
<p>以上代码中，常量<code>foo</code>指向一个冻结的对象，所以添加新属性不起作用，严格模式下还会报错。   </p>
<p>除了对象本身冻结之外，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</div><div class="line">  <span class="built_in">Object</span>.freeze(obj);</div><div class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</div><div class="line">      constantize( obj[key] );</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="let和const的区别"><a href="#let和const的区别" class="headerlink" title="let和const的区别"></a><code>let</code>和<code>const</code>的区别</h1><p><code>const</code>声明的常量需要立即赋值，否则就会报错。而且一旦声明的常量，就不可再改变其值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;const命令&quot;&gt;&lt;a href=&quot;#const命令&quot; class=&quot;headerlink&quot; title=&quot;const命令&quot;&gt;&lt;/a&gt;const命令&lt;/h1&gt;&lt;h2 id=&quot;1-基本用法&quot;&gt;&lt;a href=&quot;#1-基本用法&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="const" scheme="http://yoursite.com/tags/const/"/>
    
  </entry>
  
  <entry>
    <title>ES6学习笔记-第一篇(let命令和块级作用域)</title>
    <link href="http://yoursite.com/2017/06/02/ES6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
    <id>http://yoursite.com/2017/06/02/ES6学习笔记-第一篇/</id>
    <published>2017-06-02T02:35:24.000Z</published>
    <updated>2017-06-14T10:33:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>前言：按照自己的学习计划，先巩固JS基础，然后学习一个框架，之后再学习ES6。<br>4月份参加一个面试，面试官问我懂不懂ES6，我和他说了我的规划。面试官说，学习JS和学习框架都不影响你同时学习ES6。听了面试官的一番话之后，我觉得确实是自己懒散了。在学习其他语言的时候并不影响我学习ES6，甚至能够帮助我更好的运用ES6，4、5月一直忙毕业的事，现在学校的事情告一段落，终于有时间来填这个坑了。<br>注：ES6学习参考阮一峰老师写的<a href="http://es6.ruanyifeng.com/#docs/" target="_blank" rel="external">ES6文档</a>。</p>
<hr>
<p>1.let命令<br>基本用法：<code>let</code>命令用来声明变量，用法类似于<code>var</code>。和<code>var</code>声明变量不同的是，<code>let</code>命令只在所在的代码块内有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">a <span class="comment">//报错</span></div><div class="line">b <span class="comment">//1</span></div></pre></td></tr></table></figure></p>
<p>以上代码，在代码块内声明了a,b两个变量。然后在代码块外调用这两个变量，调用a报错，但是调用b正常。这表明，<code>let</code>声明的变量只在它的代码块的区域内有效。<br><code>for</code>循环很适合用let命令<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"FOR:"</span>+i);<span class="comment">//FOR:0; FOR:1; FOR:2;</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(i);<span class="comment">//报错</span></div></pre></td></tr></table></figure></p>
<p>以上代码，计数器<code>i</code>只在<code>for</code>循环体内有效，在循环体外就会报错；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</div><div class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[<span class="number">2</span>]();<span class="comment">//3</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = [];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;i&lt;<span class="number">3</span>;j++)&#123;</div><div class="line">    b[j]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(j);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">b[<span class="number">2</span>]();<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>上面代码中，<code>a</code>是<code>var</code>声明的，是全局变量。由于<code>for</code>循环不是块级作用域，因此<code>i</code>也是全局变量。每一次循环，<code>i</code>的值都会改变，而循环内被赋给数组<code>a</code>的<code>function</code>在运行时，会通过闭包读到这同一个变量<code>i</code>，导致最后输出的是最后一轮<code>i</code>的值为3；<br>而下面一个<code>for</code>循环使用<code>let</code>声明i，这个i的只在<code>for</code>循环中有效，且这个<code>i</code>只在每一轮中有效，每循环一次都是一个新的<code>i</code>。<br>注：在这里，JavaScript引擎内部会记住上一轮循环的值，初始化本轮变量<code>i</code>时，就在上一轮循环的基础上进行计算。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</div><div class="line">    <span class="keyword">let</span> = <span class="string">'abc'</span>;</div><div class="line">    <span class="built_in">console</span>.log(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">//abc</span></div><div class="line"><span class="comment">//abc</span></div><div class="line"><span class="comment">//abc</span></div></pre></td></tr></table></figure>
<p>以上代码最后输出了三次<code>abc</code>，这表明函数内部的变量<code>i</code>不同于循环变量<code>i</code>，有自己单独的作用域。<br>注：<code>for</code>循环设置循环变量<code>i</code>是一个父作用域，而循环内部是一个单独的子作用域。  </p>
<hr>
<h1 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//var声明的变量</span></div><div class="line"><span class="built_in">console</span>.log(a);<span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">//let声明的变量</span></div><div class="line"><span class="built_in">console</span>.log(b);<span class="comment">//报错</span></div><div class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</div></pre></td></tr></table></figure>
<hr>
<h1 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">    tmp = <span class="string">'abc'</span><span class="comment">//报错</span></div><div class="line">    <span class="keyword">let</span> tmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码，尽管在<code>if</code>之前已经用<code>var</code>声明了<code>tmp</code>，但是在<code>if</code>的作用域内又用<code>let</code>声明了<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量之前，对<code>tmp</code>赋值会报错。<br>** ES6明确规定，如果在区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”。  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">x = y,y= <span class="number">2</span></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> [x,y];</div><div class="line">&#125;</div><div class="line">fn();<span class="comment">//报错</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> x = x;<span class="comment">//不报错</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> x = x;<span class="comment">//报错</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h1><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> a =<span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> a=<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//报错</span></div><div class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> a =<span class="number">1</span>;</div><div class="line">    <span class="keyword">let</span> a=<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> b;<span class="comment">//报错</span></div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">b</span>)</span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> b;<span class="comment">//不报错</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h1><p><code>let</code>实际上为JS新增了块级作用域。<br>1.ES6允许块级作用域任意嵌套。<br>2.外层作用域无法读取内层作用域的变量；<br>3.内层作用域可以定义外层作用域的同名变量。<br>4.块级作用域的出现，可以取代立即执行函数。<br>5.可以在块级作用域中声明函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> a =<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</div><div class="line">        <span class="keyword">let</span> a = <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(a);<span class="comment">//1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;&#123;&#123;</div><div class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</div><div class="line">    &#123;<span class="keyword">let</span> b = <span class="number">3</span>;&#125;</div><div class="line">&#125;&#125;&#125;</div><div class="line"></div><div class="line"><span class="comment">//立即执行函数</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> tmp = ...;</div><div class="line">    ...</div><div class="line">&#125;)()</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> tmp = ...;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<h1 id="do表达式"><a href="#do表达式" class="headerlink" title="do表达式"></a>do表达式</h1><p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> a = f();</div><div class="line">    a = a * a + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到<code>a</code>的值，因为块级作用域没有返回值，除非<code>a</code>是全局变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="keyword">do</span>&#123;</div><div class="line">    <span class="keyword">let</span> a = f();</div><div class="line">    a * a + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>x</code>会得到整个块级作用域的返回值。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前言：按照自己的学习计划，先巩固JS基础，然后学习一个框架，之后再学习ES6。&lt;br&gt;4月份参加一个面试，面试官问我懂不懂ES6，我和他说了我的规划。面试官说，学习JS和学习框架都不影响你同时学习ES6。听了面试官的一番话之后，我觉得确实是自己懒散了。在学习其他语言的时候并
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="let" scheme="http://yoursite.com/tags/let/"/>
    
      <category term="块级作用域" scheme="http://yoursite.com/tags/%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建GitHub博客填坑指南</title>
    <link href="http://yoursite.com/2017/06/01/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BAGitHub%E5%8D%9A%E5%AE%A2%E5%A1%AB%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2017/06/01/使用hexo搭建GitHub博客填坑指南/</id>
    <published>2017-06-01T03:52:40.000Z</published>
    <updated>2017-06-14T10:33:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>在得知hexo可以快速搭建博客之后，终于在端午假期回公司之后的第一天把这个坑给填了。下面就来写一下我用hexo搭建这个博客的过程。</p>
<hr>
<h1 id="前提-GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；"><a href="#前提-GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；" class="headerlink" title="前提:GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；"></a>前提:GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；</h1><p>GitHub注册也很简单，登录<a href="https://github.com/" target="_blank" rel="external">GitHub</a>,然后点击右侧的注册、填入相应的信息即可。<br>如何在本地创建SSH秘钥和GitHub连接，可以参考这篇文章：<a href="http://www.jianshu.com/p/31cbbbc5f9fa/" target="_blank" rel="external">http://www.jianshu.com/p/31cbbbc5f9fa/</a></p>
<h1 id="一、创建GitHub仓库"><a href="#一、创建GitHub仓库" class="headerlink" title="一、创建GitHub仓库"></a>一、创建GitHub仓库</h1><p>注：GitHub为用户提供项目链接，每个用户可以生成唯一的GitHub个人链接，这个唯一的表示一个账号只能有一个URL。这个URL的格式是<code>your-name.github.io</code><br></p>
<h1 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h1><p>进入<a href="https://nodejs.org/en/" target="_blank" rel="external">node官网</a>下载node,然后按照提示安装即可；</p>
<h1 id="三、安装git"><a href="#三、安装git" class="headerlink" title="三、安装git"></a>三、安装git</h1><p>1.进入<a href="https://git-scm.com/downloads" target="_blank" rel="external">git官网</a>下载最新版本的git,下载完成后按照提示进行安装。</p>
<h1 id="四、安装hexo"><a href="#四、安装hexo" class="headerlink" title="四、安装hexo"></a>四、安装hexo</h1><p>注：前面安装node.js和git是为安装hexo做一个铺垫，hexo安装才是最重要的。<br>1.打开命令行（window在菜单栏输入cmd），在本地创建一个项目文件夹作为博客存放文件的地址。</p>
<blockquote>
<p>$ cd 项目目录</p>
</blockquote>
<p>注：项目目录可以使用拖拽的方式将项目的文件夹拖到命令行中即可；<br>2.使用npm安装hexo</p>
<blockquote>
<p>$ npm install -g hexo-cli</p>
</blockquote>
<p>3.安装好之后输入hexo检查是否安装成功</p>
<blockquote>
<p>$ hexo</p>
</blockquote>
<p>注：如果出现以下图中代码，则说明安装成功</p>
<p>4.初始化博客</p>
<blockquote>
<p>$ hexo init</p>
</blockquote>
<p>5.在项目下安装npm</p>
<blockquote>
<p>$ npm install<br>注：在安装好npm和初始化博客文件之后，在博客的文件夹下面会生成很多文件。   </p>
</blockquote>
<p>6.配置博客<br> 1）打开本地博客文件夹里面的<code>_config.yml_</code>,设置博客的一些基础信息<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: Isrenx   </div><div class="line">subtitle: 在这里记录学习轨迹、记录生活。   </div><div class="line">description: Stay hungry,Stay foolish!   </div><div class="line">author: Victor   </div><div class="line">language: zh-Hans   </div><div class="line">timezone: Asia/Shanghai</div></pre></td></tr></table></figure></p>
<p>1.其中的timezone是设置时区，其中中国区的都要设置<code>Asia/Shanghai</code>,因为根据时区的设计规则，中国区的时区是按照这个形式来指明的，切忌不要把shanghai改成beijing或者其他地区的名字，否则就会在后面添加文章的时候出错。<br>2.<code>language</code>是设置博客的语言，一般中文用<code>zh-CN</code>,这里我用的<code>zh-Hans</code>是因为我用的next主题的中文设置是这个。<br>注：所有的<code>_config.yml_</code>中的设置，冒号：后面都要输入一个空格再加上设置的内容，否则会报错。</p>
<h5 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ERROR Process failed: _posts/firstdemo.md</div><div class="line"><span class="built_in">TypeError</span>: Cannot read property <span class="string">'offset'</span> <span class="keyword">of</span> <span class="literal">null</span></div><div class="line">at <span class="built_in">Object</span>.exports.timezone (<span class="regexp">/Users/</span>victor/Desktop/workplace/IsrenxBlog/node_modules/hexo/lib/plugins/processor/common.js:<span class="number">44</span>:<span class="number">40</span>)</div></pre></td></tr></table></figure>
<p>注：如果是报上面这种错误，则说明是timezone设置错误，时区一定要设置正确，中国区必须是<code>Asia/Shanghai</code></p>
<p>7.配置部署，与GitHub对应<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https:<span class="comment">//github.com/Isrenx/Isrenx.github.io.git</span></div><div class="line">  branch: master</div></pre></td></tr></table></figure></p>
<p>其中repo后面输入你之前建好的仓库地址。。<br>仓库地址可以如下位置中找到：</p>
<p>8.在本地查看博客是否搭建成功</p>
<blockquote>
<p>$ hexo clean #清楚之前的文件     </p>
<p>$ hexo g #更新项目下的修改文件    </p>
<p>$ hexo s #生成本地的链接    </p>
</blockquote>
<p>运行以上命令之后进入浏览器访问<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a>,如果出现hexo的博客页面，则说明搭建成功。   </p>
<p>9.复制主题</p>
<blockquote>
<p>$ git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">https://github.com/iissnan/hexo-theme-next</a> themes/next</p>
</blockquote>
<p>10.启用next主题<br>打开你的博客文件夹根目录下面的<code>_config.yml_</code>，找到themes，修改成next。这样就代表启用next主题，以后切换成其他主题也要在这里进行修改。</p>
<p>11.自定义博客<br>打开博客所在的文件夹下面的themes–&gt;next–&gt;.config.yml<br>根据<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="external">next主题官网</a>中的说明修改此文件中的代码来自定义自己的博客。<br>注：因为next官网中对于各个部分都介绍的很详细，所以我就不赘述了，大家可以看官网跟着操作就行。    </p>
<p>12.将本地的博客主题文件push到GitHub上   </p>
<blockquote>
<p>cd themes/next<br>git pull     </p>
</blockquote>
<p>13.将生成的其他文件上传到GitHub   </p>
<blockquote>
<p>$ cd 博客文件夹根目录<br>$ hexo clean<br>$ hexo -g d    </p>
</blockquote>
<h3 id="至此，博客已经搭建完成。访问https-your-name-github-io-即可访问你的博客。"><a href="#至此，博客已经搭建完成。访问https-your-name-github-io-即可访问你的博客。" class="headerlink" title="至此，博客已经搭建完成。访问https://your-name.github.io/  即可访问你的博客。"></a>至此，博客已经搭建完成。访问<a href="https://your-name.github.io/" target="_blank" rel="external">https://your-name.github.io/</a>  即可访问你的博客。</h3><h1 id="五、发表文章"><a href="#五、发表文章" class="headerlink" title="五、发表文章"></a>五、发表文章</h1><p>1.在命令行中通过cd进入博客文件夹，然后在命令行中输入：</p>
<blockquote>
<p>$ hexo new “文章名称”   </p>
</blockquote>
<p>执行这个命令就在根目录下的source的_posts文件夹下面创建了一个md文件，通过在这个md文件里面使用markdown语法写文章即可。写好后的文章执行以下命令上传到GitHub：    </p>
<blockquote>
<p>$ hexo clean<br>$ hexo -g d </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在得知hexo可以快速搭建博客之后，终于在端午假期回公司之后的第一天把这个坑给填了。下面就来写一下我用hexo搭建这个博客的过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;前提-GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；&quot;&gt;&lt;a href=&quot;#前提-Gi
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>第一篇hexo博客，关于我，关于园子。</title>
    <link href="http://yoursite.com/2017/06/01/%E7%AC%AC%E4%B8%80%E7%AF%87hexo%E5%8D%9A%E5%AE%A2%EF%BC%8C%E5%85%B3%E4%BA%8E%E6%88%91%EF%BC%8C%E5%85%B3%E4%BA%8E%E5%9B%AD%E5%AD%90%E3%80%82/"/>
    <id>http://yoursite.com/2017/06/01/第一篇hexo博客，关于我，关于园子。/</id>
    <published>2017-06-01T03:13:28.000Z</published>
    <updated>2017-06-01T03:44:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>　　一直想有一个自己的博客，之前了解到可以通过WordPress来搭建一个比较完整的博客。看过一些文档，感觉用WordPress搭建博客实在太麻烦，以前也不太会使用GitHub，这个想法就搁置了。<br>　　在写文字这件事上，我不是一个勤劳的人。也不知道自己怎么慢慢的变成了这样，明明高中是靠写文字在成绩单有一些亮点。很早之前在学长的熏陶下在博客园建了一个博客，偶尔想起来的时候会在上面记录一些前端学习过程中的笔记。我是一个不太喜欢麻烦事情的人，用博客园写文章也稍显麻烦。所以我的学习笔记基本上都是写在我的为知笔记里面，而且为知笔记的同步功能也特别实用。<br>　　今年2月底的时候去了新公司之后，师兄看到我用为知做笔记，他建议我将笔记写到网上，分享给别人的同时也让大家帮忙鉴错。有时候自己写的笔记可能存在错误，如果没人发现就会一直错下去。之后又看到师兄他的博客，就请教了一下他用什么搭建的博客。在师兄的意见和自己的查阅资料之后，了解到可以用GitHub和hexo结合起来做一个简单的博客。<br>　　在新公司，任务不多，自己的学习时间就多了许多。利用这段期间开始学习Vue，学到想睡觉的时候就看看搭建博客的资料。最后，在答辩完回来上班之后的第一天把博客搭建好了。这中间遇到了很多坑，在爬坑的过程中又了解到了很多新的知识，终于觉得自己是一个程序猿了。<br>　　之后会把搭建博客的流程写一篇文章放上来，尽管用hexo搭建博客的文章比比皆是，我还是写一篇记录一下自己这个过程，也是整理自己的思路。也希望能够帮助到别人。<br>　　这个博客以后主要是记录自己在前端学习过程中遇到的一些问题和学习笔记，同时也会记录自己的一些生活，比如看书的心得、电影的影评、生活感悟之类的。总之，希望这个博客能够留下自己学习和生活的轨迹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　一直想有一个自己的博客，之前了解到可以通过WordPress来搭建一个比较完整的博客。看过一些文档，感觉用WordPress搭建博客实在太麻烦，以前也不太会使用GitHub，这个想法就搁置了。&lt;br&gt;　　在写文字这件事上，我不是一个勤劳的人。也不知道自己怎么慢慢的变成了
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
