{"meta":{"title":"Isrenx | 做个努力前进的Coder","subtitle":"成为一个Coder。","description":"Stay hungry,Stay foolish!","author":"Victor","url":"http://yoursite.com"},"pages":[{"title":"分类 | Categories","date":"2017-06-14T10:14:34.000Z","updated":"2017-06-14T10:19:29.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-06-14T10:14:34.000Z","updated":"2017-06-14T10:16:03.000Z","comments":true,"path":"categories/index-1.html","permalink":"http://yoursite.com/categories/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2017-06-14T10:20:19.000Z","updated":"2017-06-14T10:20:19.000Z","comments":true,"path":"tags/index-1.html","permalink":"http://yoursite.com/tags/index-1.html","excerpt":"","text":""},{"title":"标签 | Tags","date":"2017-06-14T10:20:19.000Z","updated":"2017-06-14T10:21:05.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-native 学习笔记(一)","slug":"react-native-学习笔记-一","date":"2018-08-23T06:57:47.000Z","updated":"2018-08-24T05:20:54.000Z","comments":true,"path":"2018/08/23/react-native-学习笔记-一/","link":"","permalink":"http://yoursite.com/2018/08/23/react-native-学习笔记-一/","excerpt":"","text":"React native 入坑杂记一 一、state（状态）\b 在RN中使用两种数据来控制一个组件：props和state。props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再\b改变。对于需要改变的数据，使用state。 \b\b目前对于react中父组件的理解：跟Vue中的父组件的概念差不多，react先用class声明一个组件，将数据和相应的数据更新操作也写在这个组件中，然后在输出默认的组件中调用之前声明的组件。props\b数据像是HTML中标签元素的某个属性。其实Vue中\bprops属性和这个也差不多\b，不过react中\b用class声明的组件不能在组件里头调用其他class声明的组件（有待后续确认）。 1) 一般来说，\bstate是在constructor中进行初始化。123456789101112131415161718192021初始化\u001b`state`有三种方式// 第一种constructor(props) &#123; super(props); this.state = &#123; msg: '第一种初始化方式' &#125;&#125;;// 第二种constructor(props) &#123; super(props); Object.assign(this.state, &#123; msg: '第二种初始化方式' &#125;)&#125;// 第三种state = &#123; msg: '第三种初始化方式'&#125; 声明多个state推荐使用以下es6的方式：1234567const &#123;text, color, status&#125; = this.state;// \b使用text&#123;text&#125;// \b使用color&#123;color&#125;// 使用status&#123;status&#125; 2) setStatesetState是一个异步执行函数，setState生效需要一个短时间间隔，不能随时set马上get。类似下面这种就不行1234this.setState(&#123; msg: '使用setState来修改msg的值'&#125;);alert(this.state.msg); 执行以上代码，\balert出来的state还是\b未setState之前的值。setState\b提供了一个回调函数来解决这个问题：12345this.setState(&#123; msg: '使用setState来修改msg的值'&#125;, () =&gt; &#123; alert(this.state.msg);&#125;); 练习：制作一段\b不断闪烁的文字；文字内容是\b固定的，通过某个值得状态\b去判断文字显示隐藏状态，使用setInterval每隔一段时间改变这个状态值；123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View &#125; from 'react-native';class Blink extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;isShowText: true&#125;; // 每1000ms对showText做取反 setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123;isShowText: !previousState.isShowText&#125;; &#125;); &#125;, 1000); &#125; render() &#123; // 根据showText判断文字显示状态 let display = this.state.isShowText ? this.props.text : ''; return ( &lt;Text&gt;&#123;display&#125;&lt;/Text&gt; ); &#125;&#125;export default class BlinkApp extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Blink text='I love to blink' /&gt; &lt;Blink text='Yes blinking is so great' /&gt; &lt;Blink text='Why did they ever take this out of HTML' /&gt; &lt;Blink text='Look at me look at me look at me' /&gt; &lt;/View&gt; ); &#125;&#125; 以上列子只是一个实现，一般不会在定时器(setTimeout和setInterval)中操作state；典型\b的场景是在接收到服务器返回的新数据，或者在用户输入数据之后。也可以使用一些“状态”容易比如redux来统一管理数据流。 二、样式在RN中，并不需要学习特殊的\b语法来定义样式。仍然是使用JavaScript来写样式。所有的核心和组件都接受style属性。\b样式名基本上遵循web上css的命名，只是按照JS的语法要求使用了驼峰命名法，列如将background-color改成backgroundColor。 style属性可以是一个普通的JavaScript对象，也可以传入一个数组。在数组中位置居后的样式对象比居前的优先级更高，\b和css样式覆盖一样的道理，这样便可间接的实现继承。 在实际开发中组件的样式会越来越复杂，建议使用StyleSheet.create来集中定义组件的样式。列如：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text, View &#125; from 'react-native';class Blink extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;isShowText: true&#125;; // 每1000ms对showText做取反 setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123;isShowText: !previousState.isShowText&#125;; &#125;); &#125;, 1000); &#125; render() &#123; // 根据showText判断文字显示状态 let display = this.state.isShowText ? this.props.text : ''; return ( &lt;Text&gt;&#123;display&#125;&lt;/Text&gt; ); &#125;&#125;export default class BlinkApp extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Blink text='I love to blink' /&gt; &lt;Blink text='Yes blinking is so great' /&gt; &lt;Blink text='Why did they ever take this out of HTML' /&gt; &lt;Blink text='Look at me look at me look at me' /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: '#fff', &#125;, welcome: &#123; fontSize: 20, textAlign: 'center', margin: 10, color: 'red', &#125;, instructions: &#123; textAlign: 'center', color: '#333333', marginBottom: 5, &#125;, greeting: &#123; color: 'blue', fontSize: 24, &#125;, blinkStatus: &#123; color: 'yellow', fontSize: 28 &#125;&#125;); 注：使用class声明自己创建的组件，在调用创建的组件时不能直接在组件上使用style，需要现在组件创建时\b利用props将style传入进去。 三、布局1)高度和宽度组件的宽度和高度决定了其在屏幕上显示的尺寸。指定宽高有两种方式\b：1.统一管理class，使用变量的形式在组件上调用；2.直接在组件上写样式；1&lt;View style=&#123;&#123;width:100, height: 50, backgroundColor: 'skyblue'&#125;&#125;&gt;&lt;/View&gt; 2)使用flex布局在RN中使用flexbox规则来指定某个组件的子元素的布局。flexbox可以再不同的屏幕尺寸上提供一致的布局。 一般来说，使用flexDirection、alignItems、justifyContent三个样式属性就已经能满足大多数布局需求。 RN中flexbox的工作原理和web上的css基本\b一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。 注：1)若组件能够撑满剩余空间\b的前提是其父容器的尺寸不为0。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为0。其子组件如果使用了flex，也是无法显示的。2)使用alignItems的stretch时，子元素在次轴方向上不能有固定的尺寸。 12345&lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'skyblue'&#125;&#125;&gt;&lt;/View&gt; &lt;View style=&#123;&#123;flex: 2, backgroundColor: 'powderblue'&#125;&#125;&gt;&lt;/View&gt; &lt;View style=&#123;&#123;flex: 3, backgroundColor: 'steelblue'&#125;&#125;&gt;&lt;/View&gt;&lt;/View&gt; 处理\b文本输入TextInput是一个允许用户输入文本的基础组件(类似input) 属性 值 描述 onChangeText \bfn() 在文本变化时调用 onSubmitEditing \bfn() 文本提交(用户按下软键盘上的提交键)时调用 练习：实现用户输入时，将以单词为单位翻译成另外一种文字。1234567891011121314151617181920212223242526272829// 把`text`保存到state中，因为它会随着时间变化。export default class App extends Component&lt;Props&gt; &#123; constructor(props) &#123; super(props); this.state = &#123; text: '' &#125;; &#125; render() &#123; let pic = &#123; uri: 'https://www.baidu.com/img/bd_logo1.png' &#125;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Image source=&#123;pic&#125; style=&#123;styles.picIcon&#125;/&gt; &lt;View style=&#123;&#123;paddingTop: 10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;width: 320, height: 40, paddingLeft: 10, borderWidth: 1, borderColor: '#ccc'&#125;&#125; placeholder='百度一下，你就知道' onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; /&gt; &lt;/View&gt; &lt;Text style=&#123;&#123;padding: 10, fontSize: 24&#125;&#125;&gt; &#123;this.state.text.split(' ').map(word =&gt; word &amp;&amp; 'baidu~').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;","categories":[],"tags":[]},{"title":"浅谈Vuex以及一些在项目中遇到的Vuex的坑","slug":"浅谈Vuex以及一些在项目中遇到的Vuex的坑","date":"2017-12-18T06:06:46.000Z","updated":"2017-12-18T10:09:05.000Z","comments":true,"path":"2017/12/18/浅谈Vuex以及一些在项目中遇到的Vuex的坑/","link":"","permalink":"http://yoursite.com/2017/12/18/浅谈Vuex以及一些在项目中遇到的Vuex的坑/","excerpt":"","text":"前言：7月底加入新的公司，第一个项目就是用Vue重构公司内部的一个系统；系统主要的交互就是通过各种拖拽来驱动数据；之前这个系统各个组件之间使用props进行通信，同时使用$emit来触发一些父组件的方法。用这种方法写的系统不太使用于中大型的系统，一旦系统的功能逐渐庞大，增加新的功能就会非常麻烦，不利于后期维护。而且使用这种方式使得各个组件耦合程度非常高。重构使用Vuex，通过vuex来进行各个组件之间的数据通信。使用vuex能将数据和状态独立于组件之外，后期一些功能的增加或修改只需要维护vuex即可。另外，一般的vue项目文件结构可能是采用模块化的形式，将各个组件的文件都放在一个文件夹（包括vuex）；这种方式有它的好处，后期在维护的时候找文件比较方便。在项目架构会上，同事建议将vuex统一抽离放在一个store里，将组件和vuex分开，将数据和状态都放在vuex里，后期维护只需要维护vuex文件即可。这两种方式各有各的优点，使用组件和vuex分开的方式更加符合Vuex存在的意义，组件只存DOM结构和css，数据都在vuex里，用数据去驱动页面； #一、Vuex语法规则state\b\b\b\b\b","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"http://yoursite.com/tags/vuex/"}]},{"title":"ES6学习笔记-第四篇(数组的扩展)","slug":"ES6学习笔记-第四篇-数组的扩展","date":"2017-06-13T07:01:10.000Z","updated":"2017-06-14T10:29:19.000Z","comments":true,"path":"2017/06/13/ES6学习笔记-第四篇-数组的扩展/","link":"","permalink":"http://yoursite.com/2017/06/13/ES6学习笔记-第四篇-数组的扩展/","excerpt":"","text":"Array.from()Array.from()将类似数组(arrayLike)的对象和可遍历的对象(包括ES6新增的数据结构Set和Map)这两类对象转换成真正的数组。 类似数组在实际应用中，常见的类似数组的对象是DOM操作返回的Nodelist集合，以及函数内部的arguments对象。类似数组对象，本质特征只有一点，就是必须有length属性，这也是为什么能使用Array.from()将它转化为数组的原因；123456789101112&#123; let arr =&#123; '0':'a', '1':'b', '2':'c', length:3 &#125;; let str = Array.from(arr); console.log(str); // ES5的写法 var arr1 = [].slice.call(arr); // ['a', 'b', 'c']&#125; 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).forEach(function (p) &#123; console.log(p);&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用forEach方法。 使用Array.from()的前提条件1.部署了Iterator接口的数据结构;12345Array.from('victor')// ['v', 'i', 'c', 't', 'o','r']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。扩展使用...扩展运算符也可以将某些数据结构转换为数组；1234567// arguments对象function foo() &#123; var args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。但是...扩展运算符有局限性，它对有length属性的类似数组对象不能转为数组； 2.任何有length属性的对象；12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from()其他用法1.如果参数是一个数组，结果还是返回一个数组；1Array.from(['a','b','c']);//['a','b','c'] 2.Array.from()还能接受第二个参数，作用类似于数组的map方法，用于对每个元素进行处理，将处理后的值放入返回的结果数组；123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] eg:将数组中布尔值为false的值换为0;12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] eg:返回各种数据的类型；12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this，Array.from()还可传入第三个参数用来绑定this; 3.Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，length制定了第二个参数运行的次数；4.Array.from()还可将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。123function countSymbols(string) &#123; return Array.from(string).length;&#125; Array.of()Array.of()是将一组值转换为数组；123Array.of(1,2,3);//[1,2,3]Array.of(1);//[1]Array.of(1).length;//1 在ES6之前的Array()方法中，因为函数参数的不同会导致Array()有不同的差异，如：123Array(2);//[,]Array();//[]Array(1,2,3);//[1,2,3] 在Array()中，只有一个参数时，Array()内部将第一个参数当做传入的值的length；只有当参数个数大于等于2的时候才是将参数转换为数组；Array.of基本上可以用来替代Array()或new Array(),并且不存在由于参数不同而导致的重载。它的行为非常统一。1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] 数组实例的copyWithin方法数组实例的copyWithin(target,start,end)方法是在当前数组内部，根据参数start(从start开始)和(到end结束)两个值的设定，将设定位置的值复制到其他位置。复制的值会覆盖原有位置的值它接受三个参数： target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。这三个参数必须是数值，如果不是数值将会转换为数值再进行复制 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位var i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署TypedArray的copyWithin方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex()方法find():找出数组中第一个符合条件的值；注：它的参数是一个回调函数，数组里面所有的值都要依次执行该回调函数，直到找到第一个返回值为true的值才结束，然后返回此时的值；如果没有符合条件的值，则返回undefined;eg:找出数组中小于3的第一个值1[1,2,3,4,5].find( (n) =&gt; n&lt;3 );//1 find()方法的回调函数能接受三个参数，依次为当前的值，当前值得位置和原数组；123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 findIndex():返回第一个符合条件的值所在的位置；注：如果所有条件都不符合，返回-1;123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 另外这两个方法都可以接受第二个参数，用来绑定回调函数的this对象；这两个方法还能找出Nan;12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 数组实例的fill()方法fill()方法使用给定值，填充指定的数组，但是会覆盖之前的数组；一般用来初始化数组比较好；1[1,2,3].fill('a');//['a','a','a'] fill()方法可以传入三个参数，第一个参数为填充的值，第二个参数是填充值的开始位置，第三个参数是填充值得结束位置；通过后面两个参数，能够制定覆盖哪些数组的值；1[1,2,3,4,5,6].fill('a',2,4);//[1,2,'a','a',5,6]; 数组实例的entries()/keys()/values()方法entries()/keys()/values()这三个方法是ES6新增用来遍历数组的，它们都返回一个遍历器对象，可以用for...of遍历；entries()是对键值对的遍历；keys()是对键名的遍历；values()是对键值的遍历；1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 在最新版的chrome中，调用console测试values()方法，报错；但是其他两个方法都能正常使用；以上values()方法的返回结果是在支持该方法中的浏览器中返回的结果如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 数组的实例includes()方法includes():表示某个数组是否包含指定的值，如包含则返回true，否则返回false;includes(value,start)第一个参数value表示查询的值，start表示查询的起始位置；如果start为负数，则表示倒数位置，如果start大于数组长度，则会重置为从0开始；第二个参数可选；12345[1,2,3,4].includes(2);//true[1,2,3,4,5].includes(4,2);//true[1,2,3,4,5].includes(2,-2);//false[1,2,3,4,5].includes(4,-2);//true[1,2,3,4,5,NaN].includes(NaN);//true 在ES6之前，查找某个数组是否包含指定的值使用indexOf();indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。123if (arr.indexOf(el) !== -1) &#123; // ...&#125; 数组的空位数组的空位是指：数组某一个位置没有任何值。比如，Array构造函数返回的数组都是空位；1Array(3);//[ , , ] 空位不是undefined，一个位置的值等于undefined还是有值得，而空位是没有任何值的。in运算符可以证明这一点120 in [undefined,undefined,undefined];//true0 in [ , , , ]; //false ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // \"#a##\"// toString方法[,'a',undefined,null].toString() // \",a,,\" 而ES6则是明确将空位转为undefined;12345678910111213141516171819202122232425262728293031Array.from(['a',,'b'])// [ \"a\", undefined, \"b\" ][...['a',,'b']]// [ \"a\", undefined, \"b\" ][,'a','b',,].copyWithin(2,0) // [,\"a\",,\"a\"]new Array(3).fill('a') // [\"a\",\"a\",\"a\"]let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1// entries()[...[,'a'].entries()] // [[0,undefined], [1,\"a\"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,\"a\"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 以上文章主要参考阮一峰老师的ES6学习指南：http://es6.ruanyifeng.com/","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"数组的扩展","slug":"数组的扩展","permalink":"http://yoursite.com/tags/数组的扩展/"}]},{"title":"ES6学习笔记-第三篇(字符串和变量的扩展)","slug":"ES6学习笔记-第三篇-字符串和变量的扩展","date":"2017-06-09T09:36:13.000Z","updated":"2017-06-14T10:30:13.000Z","comments":true,"path":"2017/06/09/ES6学习笔记-第三篇-字符串和变量的扩展/","link":"","permalink":"http://yoursite.com/2017/06/09/ES6学习笔记-第三篇-字符串和变量的扩展/","excerpt":"","text":"数值扩展1.二进制和八进制表示法ES6提供了新的二进制和八进制的写法，规定二进制前缀使用0b或0B，八进制使用0o或0O表示；从ES5开始，严格模式就规定八进制不能再使用0表示。120b111110111 === 503 // true0o767 === 503 // true 二进制、八进制转化成十进制使用Number()方法。12Number('0b111') // 7Number('0o10') // 8 2.ES6在Number上新增的方法； 1）Number.isFinite()用来检查一个数值是否为有限的(finite);对于非数值一律返回false; 12345678Number.isFinite(1);//trueNumber.isFinite(0.1);//trueNumber.isFinite(NaN);//falseNumber.isFinite(Infitity);//falseNumber.isFinite(-Infitity);//falseNumber.isFinite('string');//falseNumber.isFinite('1');//falseNumber.isFinite('true');//false 2)Number.isNaN()用来判断值是否为NaN;只对NaN返回true; 12345Number.isNaN(NaN);//trueNumber.isNaN(1);//falseNumber.isNaN('1');//falseNumber.isNaN(true);//falseNumber.isNaN(9/NaN);//false 注：它们与传统全局的isFinite()和isNaN()的区别在于——传统方法先调用Number()将非数值的值转为数值，再进行判断，而新方法只对数值有效。 3)Number.parseInt()和Number.parseFloat();ES6将全局的parseInt()和parseFloat()方法移移植到Number对象上，行为完全保持不变； 12Number.parseInt('123.45');//123Number.parseFloat('123.456@');//123.456 4)Number.isInteger()用来判断值是否为整数。在JavaScript中，整数和浮点数是同样的存储方法，3.0和3被视为同一个值； 1234Number.isInteger(23);//trueNumber.isInteger(23.0);//trueNumber.isInteger('23.0');//falseNumber.isInteger(true);//false 5)Number.EPSILON是ES6在Number对象上，新增的一个极小的常量。它主要是为浮点数计算，设置一个误差范围。因为浮点数计算不精确。在浮点数计算时，引用这个方法，如果计算结果误差小于Number.EPSILON这个常量的值，就可以认为得到了正确的结果。 12345678910Number.EPSILON // 2.220446049250313e-16Number.EPSILON.toFixed(20) // '0.00000000000000022204'0.1 + 0.2 // 0.300000000000000040.1 + 0.2 - 0.3 // 5.551115123125783e-175.551115123125783e-17.toFixed(20) // '0.00000000000000005551'5.551115123125783e-17 &lt; Number.EPSILON // true 6)Number.isSafeInteger()使用它来判断值是否在JavaScript能够表示的范围；JavaScript能够准确表示的整数范围在-2^53至2^52之间（不含两个端点），超过这个范围，无法精确表示这个值； 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992--&gt;超出临界值的数值，计算时都用临界值来计算；Math.pow(2, 53) === Math.pow(2, 53) + 1 // true 超出临界值的数值，计算时都用临界值来计算；ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true 从以上代码中，可以看到JavaScript能够精确表示的极限。123456789101112131415Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 因为超出临界值的数值，计算时都用临界值来计算；，因此在使用这个函数的时候，需要同时验证比较的两个值；123456789Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 9007199254740003 3.Math对象上的扩展（记录常用的部分）； 1)Math.trunc(a)用于去除a的小数部分，返回整数部分； 1234Math.trunc(12.34);//12Math.trunc(-12.34);//-12Math.trunc(-0.1234);//-0Math.trunc('12.34');//12 对于空值和无法截取整数的值，返回NaN;123Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaN 2)Math.sign(a)用来判断a是正数、负数还是零。它会返回五种值： 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 1234567Math.sign(-2) // -1Math.sign(2) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaNMath.sign('fn'); // NaNMath.sign(); // NaN 3)Math.cbrt(a)计算a的立方根（方法内部是先将非数值用Number转化为数值再计算); 1234567Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734Math.cbrt('8') // 2Math.cbrt('hello') // NaN 4)Math.fround(a)返回a的单精度浮点数形式； 12345Math.fround(0) // 0Math.fround(1) // 1Math.fround(1.337) // 1.3370000123977661Math.fround(1.5) // 1.5Math.fround(NaN) // NaN 对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。 5)Math.hypot()返回所有参数的平方和的平方根；如果参数非数值，会先将参数转化为数值，只要有一个参数无法转换为数值，就会返回NaN; 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 3.对数方法 1)Math.expm1()返回(e^x)-1,即Math.exp(x)-1; 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 2)Math.log1p()返回1+x的自然对数，即Math.log(1+x),如果x小于-1，返回NaN; 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN 3)Math.log10()返回以10为底的x的对数。如果x小于0，返回NaN; 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 4)Math.log2(x)返回以2为底的x的对数。如果x小于0，返回NaN; 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 5.ES6新增的三角函数方法 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 6.指数运算符ES6新增了一个指数运算符**;122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符**=;12345let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; 在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异;12345Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197 以上代码输出的结果中，最后一位小数不同； 7.Math.signbit(a)判断a的正负；前面提到的Math.sign()也是用来判断正负的，如果参数是-0返回的结果也是-0。JavaScript 内部使用64位浮点数（国际标准IEEE 754）表示数值，IEEE 754规定第一位是符号位，0表示正数，1表示负数。所以会有两种零，+0是符号位为0时的零值，-0是符号位为1时的零值。实际编程中，判断一个值是+0还是-0非常麻烦，因为它们是相等的。1+0 === -0 // true 目前，有一个提案，引入了Math.signbit()方法判断一个数的符号位是否设置了。1234Math.signbit(2) //falseMath.signbit(-2) //trueMath.signbit(0) //falseMath.signbit(-0) //true 从以上代码中我们可以看到，该方法正确返回了-0的符号位是设置了的。注： 如果参数是NaN，返回false 如果参数是-0，返回true 如果参数是负值，返回true 其他情况返回false 以上文章主要参考阮一峰老师的ES6学习指南：http://es6.ruanyifeng.com/","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"字符串扩展","slug":"字符串扩展","permalink":"http://yoursite.com/tags/字符串扩展/"},{"name":"数值扩展","slug":"数值扩展","permalink":"http://yoursite.com/tags/数值扩展/"}]},{"title":"项目填坑—H5移动端video安卓兼容、去除全屏插件、全屏","slug":"项目填坑—H5移动端video安卓兼容、去除全屏插件、全屏","date":"2017-06-06T11:29:21.000Z","updated":"2017-06-14T10:33:30.000Z","comments":true,"path":"2017/06/06/项目填坑—H5移动端video安卓兼容、去除全屏插件、全屏/","link":"","permalink":"http://yoursite.com/2017/06/06/项目填坑—H5移动端video安卓兼容、去除全屏插件、全屏/","excerpt":"","text":"前言昨天接了一个H5的开发需求，中间有一段内容是以video的形式展现，PM要求video在微信中全屏显示。其实就和之前“腾讯动漫薛之谦”的H5一样~在这里，我们说的全屏指的是微信中打开的页面内容可以展示的屏幕大小，不是指整个手机屏幕的全屏。因为这个理解不同，我和PM在沟通的时候出现了一些出入。下面主要介绍这几个方面的问题： 1.IOS全屏处理； 2.安卓系统全屏处理； 3.“隐藏”安卓系统默认的播放控件； video移动端IOS全屏处理1.在IOS系统下处理全屏显示并不难，只要加入相应的属性即可。需要加的属性有webkit-playsinline、webkit-playsinline、x-webkit-airplay=&quot;allow&quot;；但是这种方法有局限，在IOS10以下的Safari不支持该属性。2.第二种方法是使用第三方视频库实现。看之前薛之谦腾讯动漫H5用的是iphone-inline-video.browser.js。使用方法： 页面上引入iphone-inline-video.browser.js，然后调用：12var video = document.querySelector('video');makeVideoPlayableInline(video); 去掉video默认居中的播放按钮使用css:12345.IIV::-webkit-media-controls-play-button,.IIV::-webkit-media-controls-start-playback-button &#123; opacity: 0; pointer-events: none; width: 5px;&#125; 注：使用第一种方法引入属性的形式，也可使用CSS的方式去掉视频中间的播放按钮。这是webkit内核浏览器支持的属性。不过IIV是上面插件定义的class，在不引用第三方库的时候，应写成video或者video标签的类名或者id选择器; video移动端安卓系统全屏处理安卓系统处理全屏的方式就比较恶心，因为PM不断更改需求，在这一块折腾了很久。安卓手机的全屏方式目前据我所知就两种方式。1.腾讯白名单这是网上普遍的一种说法。网上很多资料都显示，微信对内核浏览器做了一些升级，没在白名单内的域名，在安卓上会全屏显示，视频后面也会有一些视频推荐。一直对这种说法抱着怀疑的态度，后来我把我的项目放到了公司线上的域名，也没有特殊的对待，虽然不是和薛之谦项目同一个域名，但是这个域名用处也很大，所以这种腾讯内部项目的说法有待考证。2.使用CSS3的scale缩放视频原理很简单：就是将视频基于某个点放大一定的倍数。对于一般需要全屏的视频需求而言，最好的处理方式是从视频的中心点放大。对于视频的缩放比例也是有要求的。看了老师之前的项目，最后我选择的是根据可视区的宽高比例和视频的宽高比来判断，来确定缩放比。具体代码见下：12345678910111213141516//JSfunction videoScale(obj)&#123; var t,i = document.body.clientWidth / document.body.clientHeight; r = 375 / 667;//这里的比例是指视频的宽高比除2之后的数值，视频是750*1334； t = i &lt; r ? document.body.clientHeight / 667 : document.body.clientWidth / 375; document.querySelector(obj).style[\"transform\"] = \"scale(\" + t + \")\"; document.querySelector(obj).style[\"-webkit-transform\"] = \"scale(\" + t + \")\"; document.querySelector(obj).style[\"webkit-transform-origin\"] = 'center center';&#125;//cssvideo&#123; position:absolute; left:50%; top:50%; margin:-333px 0 0 -188px;//视频宽高除2之后的一半&#125; video的CSS样式还需要设置outline、appearance等去除一些默认样式的属性。在这里就不一一说明了。注：这种方法的原理是将视频从视频的中心点放大，这就会导致一问题，视频边缘的部分被遮盖掉了。所以在使用这种方法之前，一定要让插入的视频留出一定的遮盖空间。 安卓手机屏幕整屏前面提到的安卓手机采用缩放视频的形式会遮盖视频，如果PM不想视频被遮盖，认为安卓手机屏幕全屏也可以，那便可采用屏幕全屏的形式（IOS不受影响）。方法：给video标签加以下属性x5-video-player-type=&#39;h5&#39;:启用H5播放器，是微信安卓的特性；采用这种方式，安卓手机的视频会充满整个手机屏幕，播放空间会消失，但是上面有一个返回按钮和其他选项按钮。点击返回按钮退出全屏，视频也停止播放。这种方式，如果用户有过多的操作，体验就不太好，而且不是那种视频嵌入页面的设计。x5-video-player-fullscreen=&#39;true&#39;:全屏设置，设置为true是防止横屏;x5-video-orientation=&#39;portraint&#39;:播放器支持的方向，landscape横屏/portrait竖屏,默认值是横屏object-fit:fill:在安卓系统的微信里，就算加上了上面的属性，还会出现上下有黑边，不能全屏。加上这个属性就可以解决。 注：除了以上问题之外，关于在安卓端视频还有另外一个问题。如果视频是在后面的页面，使用的是z-index层级切换的方式显示隐藏视频，在首屏加载的时候，安卓手机会出现一个视频块。应该是不能用这种方法来处理。还是应该通过display的方式来隐藏。考虑到DOM渲染的问题，要是z-index能实现，外加使用增删class的方式是最好的，不用重新渲染页面。","categories":[{"name":"video移动端兼容","slug":"video移动端兼容","permalink":"http://yoursite.com/categories/video移动端兼容/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://yoursite.com/tags/html5/"},{"name":"video兼容问题","slug":"video兼容问题","permalink":"http://yoursite.com/tags/video兼容问题/"}]},{"title":"ES6学习笔记-第三篇(变量的结构赋值)","slug":"ES6学习笔记-第三篇-变量的结构赋值","date":"2017-06-02T07:07:19.000Z","updated":"2017-06-14T10:32:33.000Z","comments":true,"path":"2017/06/02/ES6学习笔记-第三篇-变量的结构赋值/","link":"","permalink":"http://yoursite.com/2017/06/02/ES6学习笔记-第三篇-变量的结构赋值/","excerpt":"","text":"数组的结构赋值解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。123456//ES6之前let a = 1;let b = 2;let c = 3;//ES6let [a,b,c] = [1,2,3]; 上面代码表示：可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 下面是一些使用嵌套数组进行解构的例子：1234567891011121314151617181920let [foo,[[bar],baz]] = [1,[[2],3]];foo;//1bar;//2baz;//3let [,,third] = [\"foo\",\"bar\",\"baz\"];third; //\"baz\"let [x,,y] = [1,2,3];x; //1y; //3let [head,...tail] = [1,2,3,4];head;//1tail;//[2,3,4]let [x,y,...z] = ['a'];x; //\"a\"y; //undefinedz; //[] 如果解构不成功，变量的值就为undefined。123let [foo] = [];let [bar,foo] = [1];console.log(bar+','+foo);//1,undefined 注：以上两种情况都属于解构不成功，foo的值都会等于undefined△:在等式的两边，若左边中某个值在右边对应的值是控制，则解构失败，输出undefined;若右边的值对应的左边的值不存在或为空，不报错。 基本用法：1.可以不完全解构；即等号左边的模式，只匹配一部分的等号右边的数组；12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 2.若等号右边的不是数组（严格地说，不是可遍历的结构），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 3.set结构，也可以使用数组的解构赋值；12let [x, y, z] = new Set(['a', 'b', 'c']);x // \"a\" 4.只要数据具有Iterator接口，都可以采用数组形式的解构赋值；1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 Iterator接口:其实就是指那些能够被遍历的数据。ES6 有一种新的遍历形式for..of，而Iterator的主要作用，就是支持此操作。ESs6中有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。 默认值解构赋值允许指定默认值；12345let [foo = true] = [];foo;//truelet [x,y = \"b\"] = [\"a\"];//x=\"a\",y=\"b\"let [x,y = \"b\"] = [\"a\",undefined];//x=\"a\",y=\"b\" 注：ES6内部使用严格相等运算符===判断一个位置是否有值。因此，如果一个数组成员不严格等于undefined,默认值是不会生效的。以上代码中，第一个y因为对应右边的值为空是undefined,所以设置的默认值生效；第二个y也是如此，因为右边对应的值就是undefined,因此y就为b; 默认值的用法1.如果默认值是一个表达式，那么这个表达式是惰性求值的。即只有在用到的时候，才会求值。12345678function f()&#123; console.log(\"aaa\");&#125;&#123; let [x = f()] = [1]; console.log(x);//1&#125; 在以上代码中，因为x能够取到值，所以函数f根本不会执行。 2.默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的结构赋值解构不仅可以用于数组，还能用于对象。1234let &#123; foo, bar,baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"baz // undefined 1.对象与数组解构不同点：数组的元素是按次序排列的，变量的取值由它的位置决定。而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 2.如果变量名和属性名字不一致，必须按照下面这种写法：1234567var &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 注：foo是匹配模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo; 3.let和const声明的变量，变量不能重新声明。在解构变量时也要遵守这个规则。12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 上面代码中，let命令下面一行的圆括号是必须的。因为，解析器先解析起首的大括号，理解成一个代码块而不是赋值语句。 4.解构可用于嵌套解构的对象12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // \"Hello\"y // \"World\" 注：这是的p是模式，不是变量，因此不会被赋值；12345678910111213var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 注：上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 嵌套eg:1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 5.对象也可以指定默认值123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // \"Something went wrong\" 6.默认值生效的条件是，对象属性值严格等于undefined12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 7.解构失败，变量的值等于undefined8.解构模式是嵌套的对象，而且子对象所在的浮属性不存在，就会报错。12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 9.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构；1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。因为，字符串被转换成了一个类似数组的对象；123456const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值；12let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toSting属性，因此变量s都能取到值。 解构赋值的规则是：只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中：函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数是x和y. 1.函数参数的结构也可以使用默认值12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 2.undefined触发函数参数的默认值12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况1.变量声明语句，不能带圆括号。123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 注：模式不能使用圆括号； 2.函数参数中（函数参数也属于变量声明），模式不能带有圆括号。12// 报错function f([(z)]) &#123; return z; &#125; 3.赋值语句中，不能将整个模式或嵌套模式中的一层，放在圆括号中。123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 可以使用圆括号的情况1.赋值语句的非模式部分可以使用123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 用途交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数定义解构赋值可以方便地将一组参数与变量名对应起来1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910let jsonData = &#123; id: 42, status: \"OK\", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, \"OK\", [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789var map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + \" is \" + value);&#125;// first is hello// second is world 如果只想获取键名或者只想获取键值，可以这样写：123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(\"source-map\");","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"变量的解构赋值","slug":"变量的解构赋值","permalink":"http://yoursite.com/tags/变量的解构赋值/"}]},{"title":"ES6学习笔记-第二篇(const)","slug":"ES6学习笔记-第二篇-const","date":"2017-06-02T06:22:27.000Z","updated":"2017-06-14T10:30:44.000Z","comments":true,"path":"2017/06/02/ES6学习笔记-第二篇-const/","link":"","permalink":"http://yoursite.com/2017/06/02/ES6学习笔记-第二篇-const/","excerpt":"","text":"const命令1.基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。1234const a = 1;console.log(a);//1a = 2;//报错 const声明的变量不得改变值，这表明，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const a;console.log(a);//报错 const与let一样，只在声明所在的会计作用域内有效。12345if(true)&#123; const a = 5; console.log(a);//5&#125;console.log(a);//报错 const命令声明的常量也不能提升，同样存在暂时性死区，只能在声明的位置后面使用。1234if(true)&#123; console.log(a); const a = 1;//报错&#125; const声明的常量和let一样补课重复声明123456var a = 1;let b = 2;//以下两行代码都会报错const a = 3;const b = 4; 本质const实质上并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针,const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;//为foo添加一个属性，可以成功foo.prop = 123 ;console.log(foo.prop);//123//将foo指向另外一个对象，就会报错foo = &#123;&#125;;//报错 上面代码中，常量foo储存的是一个地址。这个地址指向一个对象，不变的只是这个地址，既不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。1234const a = [];a.push('Hello');//可执行a.length = 0;//可执行a = ['world'];//报错 以上代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a,就会报错。如果真想将对象冻结，应使用Object.freeze方法。1234const foo = Object.freeze(&#123;&#125;);//常规模式下，下面一行不起作用；//严格模式下，该行会报错；foo.prop = 123; 以上代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式下还会报错。 除了对象本身冻结之外，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数：12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; let和const的区别const声明的常量需要立即赋值，否则就会报错。而且一旦声明的常量，就不可再改变其值。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"ES6学习笔记-第一篇(let命令和块级作用域)","slug":"ES6学习笔记-第一篇","date":"2017-06-02T02:35:24.000Z","updated":"2017-06-14T10:33:01.000Z","comments":true,"path":"2017/06/02/ES6学习笔记-第一篇/","link":"","permalink":"http://yoursite.com/2017/06/02/ES6学习笔记-第一篇/","excerpt":"","text":"前言：按照自己的学习计划，先巩固JS基础，然后学习一个框架，之后再学习ES6。4月份参加一个面试，面试官问我懂不懂ES6，我和他说了我的规划。面试官说，学习JS和学习框架都不影响你同时学习ES6。听了面试官的一番话之后，我觉得确实是自己懒散了。在学习其他语言的时候并不影响我学习ES6，甚至能够帮助我更好的运用ES6，4、5月一直忙毕业的事，现在学校的事情告一段落，终于有时间来填这个坑了。注：ES6学习参考阮一峰老师写的ES6文档。 1.let命令基本用法：let命令用来声明变量，用法类似于var。和var声明变量不同的是，let命令只在所在的代码块内有效。123456&#123; let a = 1; let b = 2;&#125;a //报错b //1 以上代码，在代码块内声明了a,b两个变量。然后在代码块外调用这两个变量，调用a报错，但是调用b正常。这表明，let声明的变量只在它的代码块的区域内有效。for循环很适合用let命令1234for(let i = 0;i &lt; 3;i++)&#123; console.log(\"FOR:\"+i);//FOR:0; FOR:1; FOR:2;&#125;console.log(i);//报错 以上代码，计数器i只在for循环体内有效，在循环体外就会报错；123456789101112131415var a = [];for(var i=0;i&lt;3;i++)&#123; a[i] = function()&#123; console.log(i); &#125;&#125;a[2]();//3var b = [];for(let j=0;i&lt;3;j++)&#123; b[j]=function()&#123; console.log(j); &#125;&#125;b[2]();//2 上面代码中，a是var声明的，是全局变量。由于for循环不是块级作用域，因此i也是全局变量。每一次循环，i的值都会改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮i的值为3；而下面一个for循环使用let声明i，这个i的只在for循环中有效，且这个i只在每一轮中有效，每循环一次都是一个新的i。注：在这里，JavaScript引擎内部会记住上一轮循环的值，初始化本轮变量i时，就在上一轮循环的基础上进行计算。 1234567for(let i = 0;i &lt; 3;i++)&#123; let = 'abc'; console.log(i);&#125;//abc//abc//abc 以上代码最后输出了三次abc，这表明函数内部的变量i不同于循环变量i，有自己单独的作用域。注：for循环设置循环变量i是一个父作用域，而循环内部是一个单独的子作用域。 不存在变量提升1234567//var声明的变量console.log(a);//undefinedvar a = 1;//let声明的变量console.log(b);//报错let b = 2; 暂时性死区12345var tmp = 123;if(true)&#123; tmp = 'abc'//报错 let tmp;&#125; 以上代码，尽管在if之前已经用var声明了tmp，但是在if的作用域内又用let声明了tmp，导致后者绑定这个块级作用域，所以在let声明变量之前，对tmp赋值会报错。** ES6明确规定，如果在区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”。 12345678function fn(x = y,y= 2)&#123; return [x,y];&#125;fn();//报错var x = x;//不报错let x = x;//报错 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011121314151617181920//报错function ()&#123; let a =1; var a=2;&#125;//报错function ()&#123; let a =1; let a=2;&#125;function fn(b)&#123; let b;//报错&#125;function fn(b)&#123; &#123; let b;//不报错 &#125;&#125; 块级作用域let实际上为JS新增了块级作用域。1.ES6允许块级作用域任意嵌套。2.外层作用域无法读取内层作用域的变量；3.内层作用域可以定义外层作用域的同名变量。4.块级作用域的出现，可以取代立即执行函数。5.可以在块级作用域中声明函数。1234567891011121314151617181920212223function fn()&#123; let a =1; if(true)&#123; let a = 2; &#125; console.log(a);//1&#125;&#123;&#123;&#123; let b = 2; &#123;let b = 3;&#125;&#125;&#125;&#125;//立即执行函数(function()&#123; var tmp = ...; ...&#125;)()&#123; let tmp = ...; ...&#125; do表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。1234&#123; let a = f(); a = a * a + 1;&#125; 以上代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到a的值，因为块级作用域没有返回值，除非a是全局变量。1234let x = do&#123; let a = f(); a * a + 1;&#125; 上面代码中，变量x会得到整个块级作用域的返回值。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"let","slug":"let","permalink":"http://yoursite.com/tags/let/"},{"name":"块级作用域","slug":"块级作用域","permalink":"http://yoursite.com/tags/块级作用域/"}]},{"title":"使用hexo搭建GitHub博客填坑指南","slug":"使用hexo搭建GitHub博客填坑指南","date":"2017-06-01T03:52:40.000Z","updated":"2017-12-18T04:38:56.000Z","comments":true,"path":"2017/06/01/使用hexo搭建GitHub博客填坑指南/","link":"","permalink":"http://yoursite.com/2017/06/01/使用hexo搭建GitHub博客填坑指南/","excerpt":"","text":"在得知hexo可以快速搭建博客之后，终于在端午假期回公司之后的第一天把这个坑给填了。下面就来写一下我用hexo搭建这个博客的过程。 前提:GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；GitHub注册也很简单，登录GitHub,然后点击右侧的注册、填入相应的信息即可。如何在本地创建SSH秘钥和GitHub连接，可以参考这篇文章：http://www.jianshu.com/p/31cbbbc5f9fa/ 一、创建GitHub仓库注：GitHub为用户提供项目链接，每个用户可以生成唯一的GitHub个人链接，这个唯一的表示一个账号只能有一个URL。这个URL的格式是your-name.github.io 二、安装node.js进入node官网下载node,然后按照提示安装即可； 三、安装git1.进入git官网下载最新版本的git,下载完成后按照提示进行安装。 四、安装hexo注：前面安装node.js和git是为安装hexo做一个铺垫，hexo安装才是最重要的。1.打开命令行（window在菜单栏输入cmd），在本地创建一个项目文件夹作为博客存放文件的地址。 $ cd 项目目录 注：项目目录可以使用拖拽的方式将项目的文件夹拖到命令行中即可；2.使用npm安装hexo $ npm install -g hexo-cli 3.安装好之后输入hexo检查是否安装成功 $ hexo 注：如果出现以下图中代码，则说明安装成功 4.初始化博客 $ hexo init 5.在项目下安装npm $ npm install注：在安装好npm和初始化博客文件之后，在博客的文件夹下面会生成很多文件。 6.配置博客 1）打开本地博客文件夹里面的_config.yml_,设置博客的一些基础信息123456title: Isrenx subtitle: 在这里记录学习轨迹、记录生活。 description: Stay hungry,Stay foolish! author: Victor language: zh-Hans timezone: Asia/Shanghai 1.其中的timezone是设置时区，其中中国区的都要设置Asia/Shanghai,因为根据时区的设计规则，中国区的时区是按照这个形式来指明的，切忌不要把shanghai改成beijing或者其他地区的名字，否则就会在后面添加文章的时候出错。2.language是设置博客的语言，一般中文用zh-CN,这里我用的zh-Hans是因为我用的next主题的中文设置是这个。注：所有的_config.yml_中的设置，冒号：后面都要输入一个空格再加上设置的内容，否则会报错。 坑：123ERROR Process failed: _posts/firstdemo.mdTypeError: Cannot read property 'offset' of nullat Object.exports.timezone (/Users/victor/Desktop/workplace/IsrenxBlog/node_modules/hexo/lib/plugins/processor/common.js:44:40) 注：如果是报上面这种错误，则说明是timezone设置错误，时区一定要设置正确，中国区必须是Asia/Shanghai 7.配置部署，与GitHub对应1234deploy: type: git repo: https://github.com/Isrenx/Isrenx.github.io.git branch: master 其中repo后面输入你之前建好的仓库地址。。仓库地址可以如下位置中找到： 8.在本地查看博客是否搭建成功 $ hexo clean #清除之前的文件 $ hexo g #更新项目下的修改文件 $ hexo s #生成本地的链接 运行以上命令之后进入浏览器访问http://localhost:4000/,如果出现hexo的博客页面，则说明搭建成功。 9.复制主题 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 10.启用next主题打开你的博客文件夹根目录下面的_config.yml_，找到themes，修改成next。这样就代表启用next主题，以后切换成其他主题也要在这里进行修改。 11.自定义博客打开博客所在的文件夹下面的themes–&gt;next–&gt;.config.yml根据next主题官网中的说明修改此文件中的代码来自定义自己的博客。注：因为next官网中对于各个部分都介绍的很详细，所以我就不赘述了，大家可以看官网跟着操作就行。 12.将本地的博客主题文件push到GitHub上 cd themes/nextgit pull 13.将生成的其他文件上传到GitHub $ cd 博客文件夹根目录$ hexo clean$ hexo -g d 至此，博客已经搭建完成。访问https://your-name.github.io/ 即可访问你的博客。五、发表文章1.在命令行中通过cd进入博客文件夹，然后在命令行中输入： $ hexo new “文章名称” 执行这个命令就在根目录下的source的_posts文件夹下面创建了一个md文件，通过在这个md文件里面使用markdown语法写文章即可。写好后的文章执行以下命令上传到GitHub： $ hexo clean$ hexo -g d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"第一篇hexo博客，关于我，关于园子。","slug":"第一篇hexo博客，关于我，关于园子。","date":"2017-06-01T03:13:28.000Z","updated":"2017-06-01T03:44:05.000Z","comments":true,"path":"2017/06/01/第一篇hexo博客，关于我，关于园子。/","link":"","permalink":"http://yoursite.com/2017/06/01/第一篇hexo博客，关于我，关于园子。/","excerpt":"","text":"一直想有一个自己的博客，之前了解到可以通过WordPress来搭建一个比较完整的博客。看过一些文档，感觉用WordPress搭建博客实在太麻烦，以前也不太会使用GitHub，这个想法就搁置了。 在写文字这件事上，我不是一个勤劳的人。也不知道自己怎么慢慢的变成了这样，明明高中是靠写文字在成绩单有一些亮点。很早之前在学长的熏陶下在博客园建了一个博客，偶尔想起来的时候会在上面记录一些前端学习过程中的笔记。我是一个不太喜欢麻烦事情的人，用博客园写文章也稍显麻烦。所以我的学习笔记基本上都是写在我的为知笔记里面，而且为知笔记的同步功能也特别实用。 今年2月底的时候去了新公司之后，师兄看到我用为知做笔记，他建议我将笔记写到网上，分享给别人的同时也让大家帮忙鉴错。有时候自己写的笔记可能存在错误，如果没人发现就会一直错下去。之后又看到师兄他的博客，就请教了一下他用什么搭建的博客。在师兄的意见和自己的查阅资料之后，了解到可以用GitHub和hexo结合起来做一个简单的博客。 在新公司，任务不多，自己的学习时间就多了许多。利用这段期间开始学习Vue，学到想睡觉的时候就看看搭建博客的资料。最后，在答辩完回来上班之后的第一天把博客搭建好了。这中间遇到了很多坑，在爬坑的过程中又了解到了很多新的知识，终于觉得自己是一个程序猿了。 之后会把搭建博客的流程写一篇文章放上来，尽管用hexo搭建博客的文章比比皆是，我还是写一篇记录一下自己这个过程，也是整理自己的思路。也希望能够帮助到别人。 这个博客以后主要是记录自己在前端学习过程中遇到的一些问题和学习笔记，同时也会记录自己的一些生活，比如看书的心得、电影的影评、生活感悟之类的。总之，希望这个博客能够留下自己学习和生活的轨迹。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}