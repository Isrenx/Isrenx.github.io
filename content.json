{"meta":{"title":"Isrenx","subtitle":"在这里记录学习轨迹、记录生活。","description":"Stay hungry,Stay foolish!","author":"Victor","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-05-31T06:28:33.000Z","updated":"2017-05-31T06:28:33.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-31T06:28:37.000Z","updated":"2017-05-31T06:28:37.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ES6学习笔记-第三篇(变量的结构赋值)","slug":"ES6学习笔记-第三篇-变量的结构赋值","date":"2017-06-02T07:07:19.000Z","updated":"2017-06-02T12:07:00.000Z","comments":true,"path":"2017/06/02/ES6学习笔记-第三篇-变量的结构赋值/","link":"","permalink":"http://yoursite.com/2017/06/02/ES6学习笔记-第三篇-变量的结构赋值/","excerpt":"","text":"数组的结构赋值解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。123456//ES6之前let a = 1;let b = 2;let c = 3;//ES6let [a,b,c] = [1,2,3]; 上面代码表示：可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 下面是一些使用嵌套数组进行解构的例子：1234567891011121314151617181920let [foo,[[bar],baz]] = [1,[[2],3]];foo;//1bar;//2baz;//3let [,,third] = [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;];third; //&quot;baz&quot;let [x,,y] = [1,2,3];x; //1y; //3let [head,...tail] = [1,2,3,4];head;//1tail;//[2,3,4]let [x,y,...z] = [&apos;a&apos;];x; //&quot;a&quot;y; //undefinedz; //[] 如果解构不成功，变量的值就为undefined。123let [foo] = [];let [bar,foo] = [1];console.log(bar+&apos;,&apos;+foo);//1,undefined 注：以上两种情况都属于解构不成功，foo的值都会等于undefined△:在等式的两边，若左边中某个值在右边对应的值是控制，则解构失败，输出undefined;若右边的值对应的左边的值不存在或为空，不报错。 基本用法：1.可以不完全解构；即等号左边的模式，只匹配一部分的等号右边的数组；12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 2.若等号右边的不是数组（严格地说，不是可遍历的结构），那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 3.set结构，也可以使用数组的解构赋值；12let [x, y, z] = new Set([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]);x // &quot;a&quot; 4.只要数据具有Iterator接口，都可以采用数组形式的解构赋值；1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 Iterator接口:其实就是指那些能够被遍历的数据。ES6 有一种新的遍历形式for..of，而Iterator的主要作用，就是支持此操作。ESs6中有三类结构生来就具有Iterator接口：数组、类数组对象、Map和Set结构。 默认值解构赋值允许指定默认值；12345let [foo = true] = [];foo;//truelet [x,y = &quot;b&quot;] = [&quot;a&quot;];//x=&quot;a&quot;,y=&quot;b&quot;let [x,y = &quot;b&quot;] = [&quot;a&quot;,undefined];//x=&quot;a&quot;,y=&quot;b&quot; 注：ES6内部使用严格相等运算符===判断一个位置是否有值。因此，如果一个数组成员不严格等于undefined,默认值是不会生效的。以上代码中，第一个y因为对应右边的值为空是undefined,所以设置的默认值生效；第二个y也是如此，因为右边对应的值就是undefined,因此y就为b; 默认值的用法1.如果默认值是一个表达式，那么这个表达式是惰性求值的。即只有在用到的时候，才会求值。12345678function f()&#123; console.log(&quot;aaa&quot;);&#125;&#123; let [x = f()] = [1]; console.log(x);//1&#125; 在以上代码中，因为x能够取到值，所以函数f根本不会执行。 2.默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError 对象的结构赋值解构不仅可以用于数组，还能用于对象。1234let &#123; foo, bar,baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;baz // undefined 1.对象与数组解构不同点：数组的元素是按次序排列的，变量的取值由它的位置决定。而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 2.如果变量名和属性名字不一致，必须按照下面这种写法：1234567var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 注：foo是匹配模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo; 3.let和const声明的变量，变量不能重新声明。在解构变量时也要遵守这个规则。12345let foo;(&#123;foo&#125; = &#123;foo: 1&#125;); // 成功let baz;(&#123;bar: baz&#125; = &#123;bar: 1&#125;); // 成功 上面代码中，let命令下面一行的圆括号是必须的。因为，解析器先解析起首的大括号，理解成一个代码块而不是赋值语句。 4.解构可用于嵌套解构的对象12345678910let obj = &#123; p: [ &apos;Hello&apos;, &#123; y: &apos;World&apos; &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // &quot;Hello&quot;y // &quot;World&quot; 注：这是的p是模式，不是变量，因此不会被赋值；12345678910111213var node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;var &#123; loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // error: loc is undefinedstart // error: start is undefined 注：上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 嵌套eg:1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 5.对象也可以指定默认值123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x:y = 3&#125; = &#123;&#125;;y // 3var &#123;x:y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = &apos;Something went wrong&apos; &#125; = &#123;&#125;;msg // &quot;Something went wrong&quot; 6.默认值生效的条件是，对象属性值严格等于undefined12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 7.解构失败，变量的值等于undefined8.解构模式是嵌套的对象，而且子对象所在的浮属性不存在，就会报错。12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &apos;baz&apos;&#125;; 9.由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构；1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 字符串的解构赋值字符串也可以解构赋值。因为，字符串被转换成了一个类似数组的对象；123456const [a, b, c, d, e] = &apos;hello&apos;;a // &quot;h&quot;b // &quot;e&quot;c // &quot;l&quot;d // &quot;l&quot;e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值；12let &#123;length : len&#125; = &apos;hello&apos;;len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toSting属性，因此变量s都能取到值。 解构赋值的规则是：只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中：函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数是x和y. 1.函数参数的结构也可以使用默认值12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 2.undefined触发函数参数的默认值12[1, undefined, 3].map((x = &apos;yes&apos;) =&gt; x);// [ 1, &apos;yes&apos;, 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况1.变量声明语句，不能带圆括号。123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; 注：模式不能使用圆括号； 2.函数参数中（函数参数也属于变量声明），模式不能带有圆括号。12// 报错function f([(z)]) &#123; return z; &#125; 3.赋值语句中，不能将整个模式或嵌套模式中的一层，放在圆括号中。123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 可以使用圆括号的情况1.赋值语句的非模式部分可以使用123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 用途交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 从函数返回多个值12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); 函数参数定义解构赋值可以方便地将一组参数与变量名对应起来1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); 提取JSON数据12345678910let jsonData = &#123; id: 42, status: &quot;OK&quot;, data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, &quot;OK&quot;, [867, 5309] 函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 遍历map结构任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。123456789var map = new Map();map.set(&apos;first&apos;, &apos;hello&apos;);map.set(&apos;second&apos;, &apos;world&apos;);for (let [key, value] of map) &#123; console.log(key + &quot; is &quot; + value);&#125;// first is hello// second is world 如果只想获取键名或者只想获取键值，可以这样写：123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; 输入模块的指定方法加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"变量的解构赋值","slug":"变量的解构赋值","permalink":"http://yoursite.com/tags/变量的解构赋值/"}]},{"title":"ES6学习笔记-第二篇(const)","slug":"ES6学习笔记-第二篇-const","date":"2017-06-02T06:22:27.000Z","updated":"2017-06-02T07:23:19.000Z","comments":true,"path":"2017/06/02/ES6学习笔记-第二篇-const/","link":"","permalink":"http://yoursite.com/2017/06/02/ES6学习笔记-第二篇-const/","excerpt":"","text":"const命令1.基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。1234const a = 1;console.log(a);//1a = 2;//报错 const声明的变量不得改变值，这表明，const一旦声明变量，就必须立即初始化，不能留到以后赋值。12const a;console.log(a);//报错 const与let一样，只在声明所在的会计作用域内有效。12345if(true)&#123; const a = 5; console.log(a);//5&#125;console.log(a);//报错 const命令声明的常量也不能提升，同样存在暂时性死区，只能在声明的位置后面使用。1234if(true)&#123; console.log(a); const a = 1;//报错&#125; const声明的常量和let一样补课重复声明123456var a = 1;let b = 2;//以下两行代码都会报错const a = 3;const b = 4; 本质const实质上并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但是对于符合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针,const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。1234567const foo = &#123;&#125;;//为foo添加一个属性，可以成功foo.prop = 123 ;console.log(foo.prop);//123//将foo指向另外一个对象，就会报错foo = &#123;&#125;;//报错 上面代码中，常量foo储存的是一个地址。这个地址指向一个对象，不变的只是这个地址，既不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。1234const a = [];a.push(&apos;Hello&apos;);//可执行a.length = 0;//可执行a = [&apos;world&apos;];//报错 以上代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a,就会报错。如果真想将对象冻结，应使用Object.freeze方法。1234const foo = Object.freeze(&#123;&#125;);//常规模式下，下面一行不起作用；//严格模式下，该行会报错；foo.prop = 123; 以上代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式下还会报错。 除了对象本身冻结之外，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数：12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === &apos;object&apos; ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; let和const的区别const声明的常量需要立即赋值，否则就会报错。而且一旦声明的常量，就不可再改变其值。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"const","slug":"const","permalink":"http://yoursite.com/tags/const/"}]},{"title":"ES6学习笔记-第一篇(let命令和块级作用域)","slug":"ES6学习笔记-第一篇","date":"2017-06-02T02:35:24.000Z","updated":"2017-06-02T06:22:50.000Z","comments":true,"path":"2017/06/02/ES6学习笔记-第一篇/","link":"","permalink":"http://yoursite.com/2017/06/02/ES6学习笔记-第一篇/","excerpt":"","text":"前言：按照自己的学习计划，先巩固JS基础，然后学习一个框架，之后再学习ES6。4月份参加一个面试，面试官问我懂不懂ES6，我和他说了我的规划。面试官说，学习JS和学习框架都不影响你同时学习ES6。听了面试官的一番话之后，我觉得确实是自己懒散了。在学习其他语言的时候并不影响我学习ES6，甚至能够帮助我更好的运用ES6，4、5月一直忙毕业的事，现在学校的事情告一段落，终于有时间来填这个坑了。注：ES6学习参考阮一峰老师写的ES6文档。 1.let命令基本用法：let命令用来声明变量，用法类似于var。和var声明变量不同的是，let命令只在所在的代码块内有效。123456&#123; let a = 1; let b = 2;&#125;a //报错b //1 以上代码，在代码块内声明了a,b两个变量。然后在代码块外调用这两个变量，调用a报错，但是调用b正常。这表明，let声明的变量只在它的代码块的区域内有效。for循环很适合用let命令1234for(let i = 0;i &lt; 3;i++)&#123; console.log(&quot;FOR:&quot;+i);//FOR:0; FOR:1; FOR:2;&#125;console.log(i);//报错 以上代码，计数器i只在for循环体内有效，在循环体外就会报错；123456789101112131415var a = [];for(var i=0;i&lt;3;i++)&#123; a[i] = function()&#123; console.log(i); &#125;&#125;a[2]();//3var b = [];for(let j=0;i&lt;3;j++)&#123; b[j]=function()&#123; console.log(j); &#125;&#125;b[2]();//2 上面代码中，a是var声明的，是全局变量。由于for循环不是块级作用域，因此i也是全局变量。每一次循环，i的值都会改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮i的值为3；而下面一个for循环使用let声明i，这个i的只在for循环中有效，且这个i只在每一轮中有效，每循环一次都是一个新的i。注：在这里，JavaScript引擎内部会记住上一轮循环的值，初始化本轮变量i时，就在上一轮循环的基础上进行计算。 1234567for(let i = 0;i &lt; 3;i++)&#123; let = &apos;abc&apos;; console.log(i);&#125;//abc//abc//abc 以上代码最后输出了三次abc，这表明函数内部的变量i不同于循环变量i，有自己单独的作用域。注：for循环设置循环变量i是一个父作用域，而循环内部是一个单独的子作用域。 不存在变量提升1234567//var声明的变量console.log(a);//undefinedvar a = 1;//let声明的变量console.log(b);//报错let b = 2; 暂时性死区12345var tmp = 123;if(true)&#123; tmp = &apos;abc&apos;//报错 let tmp;&#125; 以上代码，尽管在if之前已经用var声明了tmp，但是在if的作用域内又用let声明了tmp，导致后者绑定这个块级作用域，所以在let声明变量之前，对tmp赋值会报错。** ES6明确规定，如果在区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上称为“暂时性死区”。 12345678function fn(x = y,y= 2)&#123; return [x,y];&#125;fn();//报错var x = x;//不报错let x = x;//报错 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。1234567891011121314151617181920//报错function ()&#123; let a =1; var a=2;&#125;//报错function ()&#123; let a =1; let a=2;&#125;function fn(b)&#123; let b;//报错&#125;function fn(b)&#123; &#123; let b;//不报错 &#125;&#125; 块级作用域let实际上为JS新增了块级作用域。1.ES6允许块级作用域任意嵌套。2.外层作用域无法读取内层作用域的变量；3.内层作用域可以定义外层作用域的同名变量。4.块级作用域的出现，可以取代立即执行函数。5.可以在块级作用域中声明函数。1234567891011121314151617181920212223function fn()&#123; let a =1; if(true)&#123; let a = 2; &#125; console.log(a);//1&#125;&#123;&#123;&#123; let b = 2; &#123;let b = 3;&#125;&#125;&#125;&#125;//立即执行函数(function()&#123; var tmp = ...; ...&#125;)()&#123; let tmp = ...; ...&#125; do表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。1234&#123; let a = f(); a = a * a + 1;&#125; 以上代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到a的值，因为块级作用域没有返回值，除非a是全局变量。1234let x = do&#123; let a = f(); a * a + 1;&#125; 上面代码中，变量x会得到整个块级作用域的返回值。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"let","slug":"let","permalink":"http://yoursite.com/tags/let/"},{"name":"块级作用域","slug":"块级作用域","permalink":"http://yoursite.com/tags/块级作用域/"}]},{"title":"使用hexo搭建GitHub博客填坑指南","slug":"使用hexo搭建GitHub博客填坑指南","date":"2017-06-01T03:52:40.000Z","updated":"2017-06-02T02:50:07.000Z","comments":true,"path":"2017/06/01/使用hexo搭建GitHub博客填坑指南/","link":"","permalink":"http://yoursite.com/2017/06/01/使用hexo搭建GitHub博客填坑指南/","excerpt":"","text":"在得知hexo可以快速搭建博客之后，终于在端午假期回公司之后的第一天把这个坑给填了。下面就来写一下我用hexo搭建这个博客的过程。 前提:GitHub账号注册完成，在本地创建秘钥之后和GitHub连接成功；GitHub注册也很简单，登录GitHub,然后点击右侧的注册、填入相应的信息即可。如何在本地创建SSH秘钥和GitHub连接，可以参考这篇文章：http://www.jianshu.com/p/31cbbbc5f9fa/ 一、创建GitHub仓库注：GitHub为用户提供项目链接，每个用户可以生成唯一的GitHub个人链接，这个唯一的表示一个账号只能有一个URL。这个URL的格式是your-name.github.io 二、安装node.js进入node官网下载node,然后按照提示安装即可； 三、安装git1.进入git官网下载最新版本的git,下载完成后按照提示进行安装。 四、安装hexo注：前面安装node.js和git是为安装hexo做一个铺垫，hexo安装才是最重要的。1.打开命令行（window在菜单栏输入cmd），在本地创建一个项目文件夹作为博客存放文件的地址。 $ cd 项目目录 注：项目目录可以使用拖拽的方式将项目的文件夹拖到命令行中即可；2.使用npm安装hexo $ npm install -g hexo-cli 3.安装好之后输入hexo检查是否安装成功 $ hexo 注：如果出现以下图中代码，则说明安装成功 4.初始化博客 $ hexo init 5.在项目下安装npm $ npm install注：在安装好npm和初始化博客文件之后，在博客的文件夹下面会生成很多文件。 6.配置博客 1）打开本地博客文件夹里面的_config.yml_,设置博客的一些基础信息123456title: Isrenx subtitle: 在这里记录学习轨迹、记录生活。 description: Stay hungry,Stay foolish! author: Victor language: zh-Hans timezone: Asia/Shanghai 1.其中的timezone是设置时区，其中中国区的都要设置Asia/Shanghai,因为根据时区的设计规则，中国区的时区是按照这个形式来指明的，切忌不要把shanghai改成beijing或者其他地区的名字，否则就会在后面添加文章的时候出错。2.language是设置博客的语言，一般中文用zh-CN,这里我用的zh-Hans是因为我用的next主题的中文设置是这个。注：所有的_config.yml_中的设置，冒号：后面都要输入一个空格再加上设置的内容，否则会报错。 坑：123ERROR Process failed: _posts/firstdemo.mdTypeError: Cannot read property &apos;offset&apos; of nullat Object.exports.timezone (/Users/victor/Desktop/workplace/IsrenxBlog/node_modules/hexo/lib/plugins/processor/common.js:44:40) 注：如果是报上面这种错误，则说明是timezone设置错误，时区一定要设置正确，中国区必须是Asia/Shanghai 7.配置部署，与GitHub对应1234deploy: type: git repo: https://github.com/Isrenx/Isrenx.github.io.git branch: master 其中repo后面输入你之前建好的仓库地址。。仓库地址可以如下位置中找到： 8.在本地查看博客是否搭建成功 $ hexo clean #清楚之前的文件 $ hexo g #更新项目下的修改文件 $ hexo s #生成本地的链接 运行以上命令之后进入浏览器访问http://localhost:4000/,如果出现hexo的博客页面，则说明搭建成功。 9.复制主题 $ git clone https://github.com/iissnan/hexo-theme-next themes/next 10.启用next主题打开你的博客文件夹根目录下面的_config.yml_，找到themes，修改成next。这样就代表启用next主题，以后切换成其他主题也要在这里进行修改。 11.自定义博客打开博客所在的文件夹下面的themes–&gt;next–&gt;.config.yml根据next主题官网中的说明修改此文件中的代码来自定义自己的博客。注：因为next官网中对于各个部分都介绍的很详细，所以我就不赘述了，大家可以看官网跟着操作就行。 12.将本地的博客主题文件push到GitHub上 cd themes/nextgit pull 13.将生成的其他文件上传到GitHub $ cd 博客文件夹根目录$ hexo clean$ hexo -g d 至此，博客已经搭建完成。访问https://your-name.github.io/ 即可访问你的博客。五、发表文章1.在命令行中通过cd进入博客文件夹，然后在命令行中输入： $ hexo new “文章名称” 执行这个命令就在根目录下的source的_posts文件夹下面创建了一个md文件，通过在这个md文件里面使用markdown语法写文章即可。写好后的文章执行以下命令上传到GitHub： $ hexo clean$ hexo -g d","categories":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://yoursite.com/tags/博客/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"第一篇hexo博客，关于我，关于园子。","slug":"第一篇hexo博客，关于我，关于园子。","date":"2017-06-01T03:13:28.000Z","updated":"2017-06-01T03:44:05.000Z","comments":true,"path":"2017/06/01/第一篇hexo博客，关于我，关于园子。/","link":"","permalink":"http://yoursite.com/2017/06/01/第一篇hexo博客，关于我，关于园子。/","excerpt":"","text":"一直想有一个自己的博客，之前了解到可以通过WordPress来搭建一个比较完整的博客。看过一些文档，感觉用WordPress搭建博客实在太麻烦，以前也不太会使用GitHub，这个想法就搁置了。 在写文字这件事上，我不是一个勤劳的人。也不知道自己怎么慢慢的变成了这样，明明高中是靠写文字在成绩单有一些亮点。很早之前在学长的熏陶下在博客园建了一个博客，偶尔想起来的时候会在上面记录一些前端学习过程中的笔记。我是一个不太喜欢麻烦事情的人，用博客园写文章也稍显麻烦。所以我的学习笔记基本上都是写在我的为知笔记里面，而且为知笔记的同步功能也特别实用。 今年2月底的时候去了新公司之后，师兄看到我用为知做笔记，他建议我将笔记写到网上，分享给别人的同时也让大家帮忙鉴错。有时候自己写的笔记可能存在错误，如果没人发现就会一直错下去。之后又看到师兄他的博客，就请教了一下他用什么搭建的博客。在师兄的意见和自己的查阅资料之后，了解到可以用GitHub和hexo结合起来做一个简单的博客。 在新公司，任务不多，自己的学习时间就多了许多。利用这段期间开始学习Vue，学到想睡觉的时候就看看搭建博客的资料。最后，在答辩完回来上班之后的第一天把博客搭建好了。这中间遇到了很多坑，在爬坑的过程中又了解到了很多新的知识，终于觉得自己是一个程序猿了。 之后会把搭建博客的流程写一篇文章放上来，尽管用hexo搭建博客的文章比比皆是，我还是写一篇记录一下自己这个过程，也是整理自己的思路。也希望能够帮助到别人。 这个博客以后主要是记录自己在前端学习过程中遇到的一些问题和学习笔记，同时也会记录自己的一些生活，比如看书的心得、电影的影评、生活感悟之类的。总之，希望这个博客能够留下自己学习和生活的轨迹。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}